"""
Z80 Code Generator.

Translates IR to Z80 assembly code.
"""

from dataclasses import dataclass, field
from typing import Optional

from uada80.ir import (
    IRModule,
    IRFunction,
    BasicBlock,
    IRInstr,
    OpCode,
    IRType,
    IRValue,
    VReg,
    Immediate,
    Label,
    MemoryLocation,
    ir_type_size,
)


@dataclass
class Z80Register:
    """Z80 register."""

    name: str
    is_16bit: bool = False


# Z80 registers
REG_A = Z80Register("A")
REG_B = Z80Register("B")
REG_C = Z80Register("C")
REG_D = Z80Register("D")
REG_E = Z80Register("E")
REG_H = Z80Register("H")
REG_L = Z80Register("L")
REG_BC = Z80Register("BC", True)
REG_DE = Z80Register("DE", True)
REG_HL = Z80Register("HL", True)
REG_SP = Z80Register("SP", True)
REG_IX = Z80Register("IX", True)
REG_IY = Z80Register("IY", True)


@dataclass
class RegisterAllocation:
    """Mapping of virtual registers to Z80 registers or stack slots."""

    vreg_to_reg: dict[int, Z80Register] = field(default_factory=dict)
    vreg_to_stack: dict[int, int] = field(default_factory=dict)  # stack offset
    stack_size: int = 0


class Z80CodeGen:
    """Z80 code generator."""

    def __init__(self) -> None:
        self.output: list[str] = []
        self.reg_alloc: Optional[RegisterAllocation] = None
        self.current_function: Optional[IRFunction] = None

    def generate(self, module: IRModule) -> str:
        """Generate Z80 assembly for an IR module."""
        self.output = []

        # Header
        self._emit("; Generated by uada80 Ada compiler")
        self._emit("; Target: Z80")
        self._emit("")

        # Generate globals
        if module.globals:
            self._emit("; Global variables")
            self._emit(".data")
            for name, (ir_type, size) in module.globals.items():
                self._emit(f"{name}:")
                self._emit(f"    .ds {size}")
            self._emit("")

        # Generate string literals
        if module.string_literals:
            self._emit("; String literals")
            for label, value in module.string_literals.items():
                escaped = value.replace('"', '\\"')
                self._emit(f'{label}:')
                self._emit(f'    .db "{escaped}", 0')
            self._emit("")

        # Generate vtables for tagged types
        if module.vtables:
            self._emit("; Vtables for tagged types (OOP dispatch)")
            for vtable_name, proc_names in module.vtables.items():
                self._emit(f"{vtable_name}:")
                for proc_name in proc_names:
                    self._emit(f"    .dw {proc_name}  ; slot {proc_names.index(proc_name)}")
            self._emit("")

        # Generate code
        self._emit(".code")
        self._emit("")

        for func in module.functions:
            self._generate_function(func)

        # Generate heap runtime if needed
        self._generate_heap_runtime()

        # Generate fixed-point arithmetic runtime
        self._generate_fixed_point_runtime()

        # Generate exception handling runtime
        self._generate_exc_runtime()

        # Generate string conversion runtime
        self._generate_string_runtime()

        # Generate math runtime
        self._generate_math_runtime()

        # Generate Text_IO runtime
        self._generate_text_io_runtime()

        # Generate OOP dispatch runtime
        self._generate_dispatch_runtime()

        # Generate fixed-point/float runtime
        self._generate_fixed_point_runtime()

        return "\n".join(self.output)

    def _generate_heap_runtime(self) -> None:
        """Generate simple heap allocator runtime."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Heap Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; Heap pointer (grows upward from _heap_start)")
        self._emit("_heap_ptr:")
        self._emit("    .dw _heap_start")
        self._emit("")
        self._emit("; _heap_alloc: Allocate memory from heap")
        self._emit("; Input: HL = size to allocate")
        self._emit("; Output: HL = pointer to allocated memory (0 if failed)")
        self._emit("_heap_alloc:")
        self._emit("    push DE")
        self._emit("    push BC")
        self._emit("    ; Load current heap pointer")
        self._emit("    ld DE, (_heap_ptr)")
        self._emit("    ; Save current pointer as return value")
        self._emit("    push DE")
        self._emit("    ; Advance heap pointer by size (DE += HL)")
        self._emit("    add HL, DE")
        self._emit("    ; Check for overflow (HL >= _heap_end)")
        self._emit("    ld BC, _heap_end")
        self._emit("    or A")
        self._emit("    sbc HL, BC")
        self._emit("    add HL, BC  ; restore HL")
        self._emit("    jr nc, _heap_alloc_fail")
        self._emit("    ; Store new heap pointer")
        self._emit("    ld (_heap_ptr), HL")
        self._emit("    ; Return saved pointer")
        self._emit("    pop HL")
        self._emit("    pop BC")
        self._emit("    pop DE")
        self._emit("    ret")
        self._emit("_heap_alloc_fail:")
        self._emit("    ; Return null (0)")
        self._emit("    pop HL  ; discard saved pointer")
        self._emit("    ld HL, 0")
        self._emit("    pop BC")
        self._emit("    pop DE")
        self._emit("    ret")
        self._emit("")
        self._emit("; _heap_free: Free allocated memory")
        self._emit("; Input: HL = pointer to free")
        self._emit("; Note: Simple bump allocator doesn't actually reclaim memory")
        self._emit("; A real implementation would use a free list or similar")
        self._emit("_heap_free:")
        self._emit("    ; For a bump allocator, we can't easily reclaim memory")
        self._emit("    ; Just validate the pointer is in the heap range")
        self._emit("    push DE")
        self._emit("    push BC")
        self._emit("    ; Check if HL >= _heap_start")
        self._emit("    ld DE, _heap_start")
        self._emit("    or A")
        self._emit("    sbc HL, DE")
        self._emit("    add HL, DE  ; restore HL")
        self._emit("    jr c, _heap_free_done  ; HL < _heap_start")
        self._emit("    ; Check if HL < _heap_ptr (current allocation)")
        self._emit("    ld DE, (_heap_ptr)")
        self._emit("    or A")
        self._emit("    sbc HL, DE")
        self._emit("    add HL, DE  ; restore HL")
        self._emit("    jr nc, _heap_free_done  ; HL >= _heap_ptr")
        self._emit("    ; Valid pointer - in a real allocator we'd add to free list")
        self._emit("    ; For now, just mark the memory as zero (helps debug)")
        self._emit("    ld (HL), 0")
        self._emit("    inc HL")
        self._emit("    ld (HL), 0")
        self._emit("_heap_free_done:")
        self._emit("    pop BC")
        self._emit("    pop DE")
        self._emit("    ret")
        self._emit("")
        self._emit("; Heap area (adjust size as needed)")
        self._emit("_heap_start:")
        self._emit("    .ds 2048  ; 2KB heap")
        self._emit("_heap_end:")
        self._emit("")

    def _generate_fixed_point_runtime(self) -> None:
        """Generate 16.16 fixed-point arithmetic runtime."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Fixed-Point Arithmetic Runtime (16.16)")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; _fixed_add: Add two 16.16 fixed-point numbers")
        self._emit("; Input: On stack (hi1, lo1, hi2, lo2)")
        self._emit("; Output: HL = result high word, DE = result low word")
        self._emit("_fixed_add:")
        self._emit("    ; For simplified version, just add high words")
        self._emit("    pop BC          ; return address")
        self._emit("    pop HL          ; first operand (high)")
        self._emit("    pop DE          ; temp (ignore)")
        self._emit("    pop DE          ; second operand (high)")
        self._emit("    add HL, DE")
        self._emit("    push BC         ; restore return address")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fixed_sub: Subtract two 16.16 fixed-point numbers")
        self._emit("_fixed_sub:")
        self._emit("    pop BC          ; return address")
        self._emit("    pop HL          ; first operand (high)")
        self._emit("    pop DE          ; temp (ignore)")
        self._emit("    pop DE          ; second operand (high)")
        self._emit("    or A")
        self._emit("    sbc HL, DE")
        self._emit("    push BC         ; restore return address")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fixed_mul: Multiply two 16.16 fixed-point numbers")
        self._emit("; Result = (a * b) >> 16 to maintain scaling")
        self._emit("_fixed_mul:")
        self._emit("    pop BC          ; return address")
        self._emit("    pop HL          ; first operand (high)")
        self._emit("    pop DE          ; temp (ignore)")
        self._emit("    pop DE          ; second operand (high)")
        self._emit("    ; Simple 16x16 multiply, result in HL")
        self._emit("    ; For Z80, we use a shift-and-add multiply")
        self._emit("    push BC")
        self._emit("    ld B, H")
        self._emit("    ld C, L")
        self._emit("    ld HL, 0")
        self._emit("_fixed_mul_loop:")
        self._emit("    srl D")
        self._emit("    rr E")
        self._emit("    jr nc, _fixed_mul_skip")
        self._emit("    add HL, BC")
        self._emit("_fixed_mul_skip:")
        self._emit("    sla C")
        self._emit("    rl B")
        self._emit("    ld A, D")
        self._emit("    or E")
        self._emit("    jr nz, _fixed_mul_loop")
        self._emit("    pop BC")
        self._emit("    push BC         ; restore return address")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fixed_div: Divide two 16.16 fixed-point numbers")
        self._emit("; Result = (a << 16) / b to maintain scaling")
        self._emit("_fixed_div:")
        self._emit("    pop BC          ; return address")
        self._emit("    pop HL          ; dividend (high)")
        self._emit("    pop DE          ; temp (ignore)")
        self._emit("    pop DE          ; divisor (high)")
        self._emit("    ; Simple 16/16 divide")
        self._emit("    push BC")
        self._emit("    ld A, D")
        self._emit("    or E")
        self._emit("    jr z, _fixed_div_zero")
        self._emit("    push DE")
        self._emit("    ex DE, HL")
        self._emit("    ld HL, 0")
        self._emit("    ld BC, 16")
        self._emit("_fixed_div_loop:")
        self._emit("    sla E")
        self._emit("    rl D")
        self._emit("    adc HL, HL")
        self._emit("    pop BC")
        self._emit("    push BC")
        self._emit("    or A")
        self._emit("    sbc HL, BC")
        self._emit("    jr nc, _fixed_div_set")
        self._emit("    add HL, BC")
        self._emit("    jr _fixed_div_next")
        self._emit("_fixed_div_set:")
        self._emit("    inc E")
        self._emit("_fixed_div_next:")
        self._emit("    pop BC")
        self._emit("    push BC")
        self._emit("    dec B")
        self._emit("    jr nz, _fixed_div_loop")
        self._emit("    pop BC")
        self._emit("    ex DE, HL")
        self._emit("    pop BC")
        self._emit("    push BC         ; restore return address")
        self._emit("    ret")
        self._emit("_fixed_div_zero:")
        self._emit("    ; Division by zero - return max value")
        self._emit("    ld HL, 0x7FFF")
        self._emit("    pop BC")
        self._emit("    push BC         ; restore return address")
        self._emit("    ret")
        self._emit("")

    def _generate_exc_runtime(self) -> None:
        """Generate exception handling runtime."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Exception Handling Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; Exception state variables")
        self._emit("_exc_handler:")
        self._emit("    .dw 0  ; current handler chain head (0 = none)")
        self._emit("_exc_current:")
        self._emit("    .dw 0  ; currently raised exception ID")
        self._emit("_exc_message:")
        self._emit("    .dw 0  ; exception message pointer (0 = none)")
        self._emit("")
        self._emit("; _exc_do_raise: Process a raised exception")
        self._emit("; Expects _exc_current and _exc_message to be set")
        self._emit("; Searches handler chain for matching handler")
        self._emit("_exc_do_raise:")
        self._emit("    ; Get current handler")
        self._emit("    ld HL, (_exc_handler)")
        self._emit("    ld A, H")
        self._emit("    or L")
        self._emit("    jr z, _exc_unhandled  ; no handler - halt")
        self._emit("")
        self._emit("_exc_check_handler:")
        self._emit("    ; HL points to handler frame")
        self._emit("    ; Frame: +0=prev, +2=SP, +4=addr, +6=exc_id")
        self._emit("    push HL  ; save frame pointer")
        self._emit("")
        self._emit("    ; Get exception ID this handler catches (+6)")
        self._emit("    ld DE, 6")
        self._emit("    add HL, DE")
        self._emit("    ld E, (HL)")
        self._emit("    inc HL")
        self._emit("    ld D, (HL)")
        self._emit("")
        self._emit("    ; Check if handler catches all (ID = 0)")
        self._emit("    ld A, D")
        self._emit("    or E")
        self._emit("    jr z, _exc_handler_match  ; catches all")
        self._emit("")
        self._emit("    ; Check if handler ID matches raised exception")
        self._emit("    ld HL, (_exc_current)")
        self._emit("    or A  ; clear carry")
        self._emit("    sbc HL, DE")
        self._emit("    jr z, _exc_handler_match  ; ID matches")
        self._emit("")
        self._emit("    ; No match - try previous handler")
        self._emit("    pop HL  ; restore frame pointer")
        self._emit("    ; Get previous handler (+0)")
        self._emit("    ld E, (HL)")
        self._emit("    inc HL")
        self._emit("    ld D, (HL)")
        self._emit("    ex DE, HL  ; HL = previous handler")
        self._emit("")
        self._emit("    ; Check if there's a previous handler")
        self._emit("    ld A, H")
        self._emit("    or L")
        self._emit("    jr nz, _exc_check_handler  ; try previous")
        self._emit("    jr _exc_unhandled  ; no more handlers")
        self._emit("")
        self._emit("_exc_handler_match:")
        self._emit("    ; Found matching handler")
        self._emit("    pop HL  ; restore frame pointer")
        self._emit("")
        self._emit("    ; Get previous handler and update chain")
        self._emit("    ld E, (HL)")
        self._emit("    inc HL")
        self._emit("    ld D, (HL)")
        self._emit("    inc HL")
        self._emit("    ld (_exc_handler), DE")
        self._emit("")
        self._emit("    ; Get saved SP (+2)")
        self._emit("    ld E, (HL)")
        self._emit("    inc HL")
        self._emit("    ld D, (HL)")
        self._emit("    inc HL")
        self._emit("")
        self._emit("    ; Get handler address (+4)")
        self._emit("    ld A, (HL)")
        self._emit("    inc HL")
        self._emit("    ld H, (HL)")
        self._emit("    ld L, A  ; HL = handler address")
        self._emit("")
        self._emit("    ; Restore SP and jump to handler")
        self._emit("    ex DE, HL  ; DE = handler addr, HL = saved SP")
        self._emit("    ld SP, HL")
        self._emit("    ex DE, HL  ; HL = handler addr")
        self._emit("    jp (HL)   ; jump to handler")
        self._emit("")
        self._emit("_exc_unhandled:")
        self._emit("    ; No handler found - halt with error")
        self._emit("    ; Could output error message here")
        self._emit("    halt")
        self._emit("")
        self._emit("; Predefined exception raise routines")
        self._emit("; These have fixed exception IDs matching ASTLowering.PREDEFINED_EXCEPTIONS")
        self._emit("_raise_constraint_error:")
        self._emit("    ; Constraint_Error = ID 1")
        self._emit("    ld HL, 1")
        self._emit("    ld (_exc_current), HL")
        self._emit("    ld HL, 0")
        self._emit("    ld (_exc_message), HL")
        self._emit("    call _exc_do_raise")
        self._emit("")
        self._emit("_raise_program_error:")
        self._emit("    ; Program_Error = ID 2")
        self._emit("    ld HL, 2")
        self._emit("    ld (_exc_current), HL")
        self._emit("    ld HL, 0")
        self._emit("    ld (_exc_message), HL")
        self._emit("    call _exc_do_raise")
        self._emit("")
        self._emit("_raise_storage_error:")
        self._emit("    ; Storage_Error = ID 3")
        self._emit("    ld HL, 3")
        self._emit("    ld (_exc_current), HL")
        self._emit("    ld HL, 0")
        self._emit("    ld (_exc_message), HL")
        self._emit("    call _exc_do_raise")
        self._emit("")

    def _generate_string_runtime(self) -> None:
        """Generate string conversion runtime (Image/Value)."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; String Conversion Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; Static buffer for Integer'Image result")
        self._emit("_int_str_buf:")
        self._emit("    .ds 8  ; -32768 is 6 chars + sign + null")
        self._emit("")
        self._emit("; _int_to_str: Convert signed 16-bit integer to string")
        self._emit("; Input: Stack: value (16-bit signed)")
        self._emit("; Output: HL = pointer to null-terminated string")
        self._emit("_int_to_str:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get value from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ; Point DE to end of buffer")
        self._emit("    ld DE, _int_str_buf + 7")
        self._emit("    xor A")
        self._emit("    ld (DE), A  ; null terminator")
        self._emit("    dec DE")
        self._emit("    ; Check for negative")
        self._emit("    bit 7, H")
        self._emit("    push AF  ; save sign flag")
        self._emit("    jr z, _its_loop")
        self._emit("    ; Negate HL")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("_its_loop:")
        self._emit("    ; Divide HL by 10, remainder in A")
        self._emit("    push DE")
        self._emit("    ld DE, 10")
        self._emit("    call _div16_mod  ; HL = HL/10, A = remainder")
        self._emit("    pop DE")
        self._emit("    add A, '0'")
        self._emit("    ld (DE), A")
        self._emit("    dec DE")
        self._emit("    ; Check if HL is zero")
        self._emit("    ld A, H")
        self._emit("    or L")
        self._emit("    jr nz, _its_loop")
        self._emit("    ; Add minus sign if needed")
        self._emit("    pop AF  ; restore sign flag")
        self._emit("    jr z, _its_done")
        self._emit("    ld A, '-'")
        self._emit("    ld (DE), A")
        self._emit("    dec DE")
        self._emit("_its_done:")
        self._emit("    ; Return pointer to start of string")
        self._emit("    inc DE")
        self._emit("    ex DE, HL")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _str_to_int: Convert string to signed 16-bit integer")
        self._emit("; Input: Stack: pointer to null-terminated string")
        self._emit("; Output: HL = value")
        self._emit("_str_to_int:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get string pointer from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ; Result in DE")
        self._emit("    ld DE, 0")
        self._emit("    ; Check for leading minus")
        self._emit("    ld A, (HL)")
        self._emit("    ld C, 0  ; sign flag")
        self._emit("    cp '-'")
        self._emit("    jr nz, _sti_skip_ws")
        self._emit("    ld C, 1  ; negative")
        self._emit("    inc HL")
        self._emit("_sti_skip_ws:")
        self._emit("    ; Skip leading spaces")
        self._emit("    ld A, (HL)")
        self._emit("    cp ' '")
        self._emit("    jr nz, _sti_loop")
        self._emit("    inc HL")
        self._emit("    jr _sti_skip_ws")
        self._emit("_sti_loop:")
        self._emit("    ld A, (HL)")
        self._emit("    or A")
        self._emit("    jr z, _sti_done")
        self._emit("    cp '0'")
        self._emit("    jr c, _sti_done")
        self._emit("    cp '9'+1")
        self._emit("    jr nc, _sti_done")
        self._emit("    ; DE = DE * 10 + (A - '0')")
        self._emit("    sub '0'")
        self._emit("    push HL")
        self._emit("    push BC")
        self._emit("    ; DE * 10")
        self._emit("    ex DE, HL")
        self._emit("    add HL, HL  ; *2")
        self._emit("    push HL")
        self._emit("    add HL, HL  ; *4")
        self._emit("    add HL, HL  ; *8")
        self._emit("    pop DE")
        self._emit("    add HL, DE  ; *10")
        self._emit("    ; Add digit")
        self._emit("    ld E, A")
        self._emit("    ld D, 0")
        self._emit("    add HL, DE")
        self._emit("    ex DE, HL")
        self._emit("    pop BC")
        self._emit("    pop HL")
        self._emit("    inc HL")
        self._emit("    jr _sti_loop")
        self._emit("_sti_done:")
        self._emit("    ; Check sign and negate if needed")
        self._emit("    ld A, C")
        self._emit("    or A")
        self._emit("    jr z, _sti_ret")
        self._emit("    ; Negate DE")
        self._emit("    xor A")
        self._emit("    sub E")
        self._emit("    ld E, A")
        self._emit("    sbc A, A")
        self._emit("    sub D")
        self._emit("    ld D, A")
        self._emit("_sti_ret:")
        self._emit("    ex DE, HL")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _str_concat: Concatenate two null-terminated strings")
        self._emit("; Input: Stack: str1_ptr (16-bit), str2_ptr (16-bit)")
        self._emit("; Output: HL = pointer to new string (in static buffer)")
        self._emit("; Note: Uses static buffer, not reentrant")
        self._emit("_str_concat:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    push BC")
        self._emit("    push DE")
        self._emit("    ; Get str1 pointer from stack (at IX+6)")
        self._emit("    ld L, (IX+6)")
        self._emit("    ld H, (IX+7)")
        self._emit("    ; Point DE to concatenation buffer")
        self._emit("    ld DE, _str_concat_buf")
        self._emit("    push DE  ; save result pointer")
        self._emit("    ; Copy str1")
        self._emit("_str_concat_copy1:")
        self._emit("    ld A, (HL)")
        self._emit("    or A")
        self._emit("    jr z, _str_concat_copy2_start")
        self._emit("    ld (DE), A")
        self._emit("    inc HL")
        self._emit("    inc DE")
        self._emit("    jr _str_concat_copy1")
        self._emit("_str_concat_copy2_start:")
        self._emit("    ; Get str2 pointer from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ; Copy str2")
        self._emit("_str_concat_copy2:")
        self._emit("    ld A, (HL)")
        self._emit("    ld (DE), A")
        self._emit("    or A")
        self._emit("    jr z, _str_concat_done")
        self._emit("    inc HL")
        self._emit("    inc DE")
        self._emit("    jr _str_concat_copy2")
        self._emit("_str_concat_done:")
        self._emit("    pop HL  ; return pointer to buffer")
        self._emit("    pop DE")
        self._emit("    pop BC")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; Static buffer for string concatenation")
        self._emit("_str_concat_buf:")
        self._emit("    .ds 256  ; max concatenated string length")
        self._emit("")
        self._emit("; _str_len: Get length of null-terminated string")
        self._emit("; Input: HL = pointer to string")
        self._emit("; Output: HL = length (not including null)")
        self._emit("_str_len:")
        self._emit("    push BC")
        self._emit("    ld BC, 0")
        self._emit("_str_len_loop:")
        self._emit("    ld A, (HL)")
        self._emit("    or A")
        self._emit("    jr z, _str_len_done")
        self._emit("    inc HL")
        self._emit("    inc BC")
        self._emit("    jr _str_len_loop")
        self._emit("_str_len_done:")
        self._emit("    ld H, B")
        self._emit("    ld L, C")
        self._emit("    pop BC")
        self._emit("    ret")
        self._emit("")
        self._emit("; _str_cmp: Compare two null-terminated strings")
        self._emit("; Input: Stack: str1_ptr (16-bit), str2_ptr (16-bit)")
        self._emit("; Output: HL = negative if str1 < str2, 0 if equal, positive if str1 > str2")
        self._emit("_str_cmp:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    push BC")
        self._emit("    push DE")
        self._emit("    ; Get str1 pointer from stack (at IX+6)")
        self._emit("    ld L, (IX+6)")
        self._emit("    ld H, (IX+7)")
        self._emit("    ; Get str2 pointer from stack (at IX+4)")
        self._emit("    ld E, (IX+4)")
        self._emit("    ld D, (IX+5)")
        self._emit("_str_cmp_loop:")
        self._emit("    ld A, (HL)")
        self._emit("    ld B, A")
        self._emit("    ld A, (DE)")
        self._emit("    ; Compare characters")
        self._emit("    cp B")
        self._emit("    jr nz, _str_cmp_diff")
        self._emit("    ; Characters equal, check if end of string")
        self._emit("    or A")
        self._emit("    jr z, _str_cmp_equal")
        self._emit("    ; Move to next character")
        self._emit("    inc HL")
        self._emit("    inc DE")
        self._emit("    jr _str_cmp_loop")
        self._emit("_str_cmp_diff:")
        self._emit("    ; Characters differ: B = char1, A = char2")
        self._emit("    ; Return char1 - char2 (negative if str1 < str2, positive if str1 > str2)")
        self._emit("    ld A, B")
        self._emit("    ld B, (DE)  ; get char2 again")
        self._emit("    sub B")
        self._emit("    ; Sign-extend A to HL")
        self._emit("    ld L, A")
        self._emit("    rlca")
        self._emit("    sbc A, A")
        self._emit("    ld H, A")
        self._emit("    jr _str_cmp_done")
        self._emit("_str_cmp_equal:")
        self._emit("    ld HL, 0")
        self._emit("_str_cmp_done:")
        self._emit("    pop DE")
        self._emit("    pop BC")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _memcpy: Copy block of memory")
        self._emit("; Input: Stack: dest (16-bit), src (16-bit), count (16-bit)")
        self._emit("; Output: None")
        self._emit("_memcpy:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    push BC")
        self._emit("    push DE")
        self._emit("    push HL")
        self._emit("    ; Get dest pointer from stack (at IX+8)")
        self._emit("    ld E, (IX+8)")
        self._emit("    ld D, (IX+9)")
        self._emit("    ; Get src pointer from stack (at IX+6)")
        self._emit("    ld L, (IX+6)")
        self._emit("    ld H, (IX+7)")
        self._emit("    ; Get count from stack (at IX+4)")
        self._emit("    ld C, (IX+4)")
        self._emit("    ld B, (IX+5)")
        self._emit("    ; Check if count is 0")
        self._emit("    ld A, B")
        self._emit("    or C")
        self._emit("    jr z, _memcpy_done")
        self._emit("    ; Use LDIR for efficient block copy")
        self._emit("    ldir")
        self._emit("_memcpy_done:")
        self._emit("    pop HL")
        self._emit("    pop DE")
        self._emit("    pop BC")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _protected_lock: Acquire lock on protected object")
        self._emit("; Input: Stack: ptr to protected object (lock byte is at offset 0)")
        self._emit("; Output: None (spins until lock acquired)")
        self._emit("_protected_lock:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get protected object pointer from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("_prot_lock_spin:")
        self._emit("    ; Try to acquire lock (test and set)")
        self._emit("    di             ; Disable interrupts")
        self._emit("    ld A, (HL)")
        self._emit("    or A")
        self._emit("    jr nz, _prot_lock_wait")
        self._emit("    ld (HL), 1     ; Set lock")
        self._emit("    ei             ; Re-enable interrupts")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("_prot_lock_wait:")
        self._emit("    ei             ; Re-enable interrupts")
        self._emit("    ; Simple spin wait")
        self._emit("    jr _prot_lock_spin")
        self._emit("")
        self._emit("; _protected_unlock: Release lock on protected object")
        self._emit("; Input: Stack: ptr to protected object")
        self._emit("; Output: None")
        self._emit("_protected_unlock:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get protected object pointer from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ; Clear lock")
        self._emit("    xor A")
        self._emit("    ld (HL), A")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")

    def _generate_math_runtime(self) -> None:
        """Generate math runtime (multiply, divide)."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Math Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; _mul16: 16-bit signed multiply")
        self._emit("; Input: HL = multiplicand, DE = multiplier")
        self._emit("; Output: HL = product (low 16 bits)")
        self._emit("_mul16:")
        self._emit("    push BC")
        self._emit("    ld B, H")
        self._emit("    ld C, L")
        self._emit("    ld HL, 0")
        self._emit("_mul16_loop:")
        self._emit("    ld A, D")
        self._emit("    or E")
        self._emit("    jr z, _mul16_done")
        self._emit("    srl D")
        self._emit("    rr E")
        self._emit("    jr nc, _mul16_skip")
        self._emit("    add HL, BC")
        self._emit("_mul16_skip:")
        self._emit("    sla C")
        self._emit("    rl B")
        self._emit("    jr _mul16_loop")
        self._emit("_mul16_done:")
        self._emit("    pop BC")
        self._emit("    ret")
        self._emit("")
        self._emit("; _div16: 16-bit signed divide")
        self._emit("; Input: HL = dividend, DE = divisor")
        self._emit("; Output: HL = quotient")
        self._emit("_div16:")
        self._emit("    push BC")
        self._emit("    ; Handle signs")
        self._emit("    ld A, H")
        self._emit("    xor D")
        self._emit("    push AF  ; save result sign")
        self._emit("    ; Make both positive")
        self._emit("    bit 7, H")
        self._emit("    jr z, _div16_pos1")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("_div16_pos1:")
        self._emit("    bit 7, D")
        self._emit("    jr z, _div16_pos2")
        self._emit("    xor A")
        self._emit("    sub E")
        self._emit("    ld E, A")
        self._emit("    sbc A, A")
        self._emit("    sub D")
        self._emit("    ld D, A")
        self._emit("_div16_pos2:")
        self._emit("    call _div16_unsigned")
        self._emit("    ; Apply sign to result")
        self._emit("    pop AF")
        self._emit("    bit 7, A")
        self._emit("    jr z, _div16_ret")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("_div16_ret:")
        self._emit("    pop BC")
        self._emit("    ret")
        self._emit("")
        self._emit("; _div16_unsigned: 16-bit unsigned divide")
        self._emit("; Input: HL = dividend, DE = divisor")
        self._emit("; Output: HL = quotient, BC = remainder")
        self._emit("_div16_unsigned:")
        self._emit("    ld BC, 0  ; remainder")
        self._emit("    ld A, 16  ; bit counter")
        self._emit("_div16u_loop:")
        self._emit("    ; Shift dividend left into remainder")
        self._emit("    add HL, HL")
        self._emit("    rl C")
        self._emit("    rl B")
        self._emit("    ; Try subtract divisor from remainder")
        self._emit("    push HL")
        self._emit("    ld H, B")
        self._emit("    ld L, C")
        self._emit("    or A")
        self._emit("    sbc HL, DE")
        self._emit("    jr c, _div16u_skip")
        self._emit("    ; Subtraction succeeded")
        self._emit("    ld B, H")
        self._emit("    ld C, L")
        self._emit("    pop HL")
        self._emit("    inc L  ; set quotient bit")
        self._emit("    jr _div16u_next")
        self._emit("_div16u_skip:")
        self._emit("    pop HL")
        self._emit("_div16u_next:")
        self._emit("    dec A")
        self._emit("    jr nz, _div16u_loop")
        self._emit("    ret")
        self._emit("")
        self._emit("; _div16_mod: 16-bit unsigned divide with modulo")
        self._emit("; Input: HL = dividend, DE = divisor")
        self._emit("; Output: HL = quotient, A = remainder (low byte)")
        self._emit("_div16_mod:")
        self._emit("    call _div16_unsigned")
        self._emit("    ld A, C  ; remainder low byte")
        self._emit("    ret")
        self._emit("")
        self._emit("; _mod16: 16-bit signed modulo")
        self._emit("; Input: HL = dividend, DE = divisor")
        self._emit("; Output: HL = dividend mod divisor (Ada semantics)")
        self._emit("; Note: Ada mod has sign of divisor, different from rem")
        self._emit("_mod16:")
        self._emit("    push BC")
        self._emit("    ; Save signs for later")
        self._emit("    ld A, H")
        self._emit("    xor D")
        self._emit("    push AF  ; save combined sign for mod adjustment")
        self._emit("    ld A, D")
        self._emit("    push AF  ; save divisor sign")
        self._emit("    ; Make both positive")
        self._emit("    bit 7, H")
        self._emit("    jr z, _mod16_pos1")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("_mod16_pos1:")
        self._emit("    bit 7, D")
        self._emit("    jr z, _mod16_pos2")
        self._emit("    xor A")
        self._emit("    sub E")
        self._emit("    ld E, A")
        self._emit("    sbc A, A")
        self._emit("    sub D")
        self._emit("    ld D, A")
        self._emit("_mod16_pos2:")
        self._emit("    ; Now do unsigned divide, remainder in BC")
        self._emit("    call _div16_unsigned")
        self._emit("    ; Result remainder is in BC, move to HL")
        self._emit("    ld H, B")
        self._emit("    ld L, C")
        self._emit("    ; Ada mod: result has sign of divisor")
        self._emit("    ; If remainder is zero, we're done")
        self._emit("    ld A, H")
        self._emit("    or L")
        self._emit("    jr z, _mod16_done")
        self._emit("    ; If signs differed and remainder != 0,")
        self._emit("    ; adjust: result = divisor - remainder")
        self._emit("    pop AF  ; divisor sign")
        self._emit("    pop BC  ; combined sign (in B's bit 7)")
        self._emit("    bit 7, B")
        self._emit("    jr z, _mod16_apply_sign")
        self._emit("    ; Signs differed - adjust result")
        self._emit("    push DE  ; save divisor")
        self._emit("    ex DE, HL")
        self._emit("    pop HL   ; HL = divisor")
        self._emit("    or A")
        self._emit("    sbc HL, DE  ; HL = divisor - remainder")
        self._emit("    jr _mod16_apply_sign2")
        self._emit("_mod16_apply_sign:")
        self._emit("    ; Apply divisor's sign to result")
        self._emit("    bit 7, A")
        self._emit("    jr z, _mod16_ret")
        self._emit("_mod16_apply_sign2:")
        self._emit("    ; Negate result if divisor was negative")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("    jr _mod16_ret")
        self._emit("_mod16_done:")
        self._emit("    pop AF")
        self._emit("    pop AF")
        self._emit("_mod16_ret:")
        self._emit("    pop BC")
        self._emit("    ret")
        self._emit("")
        self._emit("; _rem16: 16-bit signed remainder")
        self._emit("; Input: HL = dividend, DE = divisor")
        self._emit("; Output: HL = dividend rem divisor (Ada semantics)")
        self._emit("; Note: Ada rem has sign of dividend, different from mod")
        self._emit("_rem16:")
        self._emit("    push BC")
        self._emit("    ; Save dividend sign for result")
        self._emit("    ld A, H")
        self._emit("    push AF  ; save dividend sign")
        self._emit("    ; Make both positive")
        self._emit("    bit 7, H")
        self._emit("    jr z, _rem16_pos1")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("_rem16_pos1:")
        self._emit("    bit 7, D")
        self._emit("    jr z, _rem16_pos2")
        self._emit("    xor A")
        self._emit("    sub E")
        self._emit("    ld E, A")
        self._emit("    sbc A, A")
        self._emit("    sub D")
        self._emit("    ld D, A")
        self._emit("_rem16_pos2:")
        self._emit("    ; Do unsigned divide, remainder in BC")
        self._emit("    call _div16_unsigned")
        self._emit("    ; Result remainder is in BC, move to HL")
        self._emit("    ld H, B")
        self._emit("    ld L, C")
        self._emit("    ; Ada rem: result has sign of dividend")
        self._emit("    pop AF  ; dividend sign")
        self._emit("    bit 7, A")
        self._emit("    jr z, _rem16_ret")
        self._emit("    ; Negate result if dividend was negative")
        self._emit("    ld A, H")
        self._emit("    or L")
        self._emit("    jr z, _rem16_ret  ; don't negate zero")
        self._emit("    xor A")
        self._emit("    sub L")
        self._emit("    ld L, A")
        self._emit("    sbc A, A")
        self._emit("    sub H")
        self._emit("    ld H, A")
        self._emit("_rem16_ret:")
        self._emit("    pop BC")
        self._emit("    ret")
        self._emit("")
        self._emit("; _shl16: 16-bit left shift")
        self._emit("; Input: HL = value, DE = shift count")
        self._emit("; Output: HL = value << count")
        self._emit("_shl16:")
        self._emit("    ld A, E")
        self._emit("    or A")
        self._emit("    ret z        ; no shift needed")
        self._emit("    cp 16")
        self._emit("    jr c, _shl16_loop")
        self._emit("    ld HL, 0     ; shift >= 16 yields 0")
        self._emit("    ret")
        self._emit("_shl16_loop:")
        self._emit("    add HL, HL   ; HL = HL * 2")
        self._emit("    dec A")
        self._emit("    jr nz, _shl16_loop")
        self._emit("    ret")
        self._emit("")
        self._emit("; _shr16: 16-bit logical right shift (unsigned)")
        self._emit("; Input: HL = value, DE = shift count")
        self._emit("; Output: HL = value >> count")
        self._emit("_shr16:")
        self._emit("    ld A, E")
        self._emit("    or A")
        self._emit("    ret z        ; no shift needed")
        self._emit("    cp 16")
        self._emit("    jr c, _shr16_loop")
        self._emit("    ld HL, 0     ; shift >= 16 yields 0")
        self._emit("    ret")
        self._emit("_shr16_loop:")
        self._emit("    srl H        ; shift high byte right")
        self._emit("    rr L         ; rotate low byte right with carry")
        self._emit("    dec A")
        self._emit("    jr nz, _shr16_loop")
        self._emit("    ret")
        self._emit("")
        self._emit("; _exp16: 16-bit integer exponentiation (base ** exp)")
        self._emit("; Input: Stack: base (16-bit), exponent (16-bit)")
        self._emit("; Output: HL = base ** exponent")
        self._emit("; Uses binary exponentiation for efficiency")
        self._emit("_exp16:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get base from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ; Get exponent from stack (at IX+6)")
        self._emit("    ld E, (IX+6)")
        self._emit("    ld D, (IX+7)")
        self._emit("    ; Handle exponent = 0 -> result = 1")
        self._emit("    ld A, D")
        self._emit("    or E")
        self._emit("    jr nz, _exp16_init")
        self._emit("    ld HL, 1")
        self._emit("    jr _exp16_done")
        self._emit("_exp16_init:")
        self._emit("    ; Save base in BC, result = 1 in HL")
        self._emit("    ld B, H")
        self._emit("    ld C, L")
        self._emit("    ld HL, 1")
        self._emit("_exp16_loop:")
        self._emit("    ld A, D")
        self._emit("    or E")
        self._emit("    jr z, _exp16_done")
        self._emit("    ; If exp is odd, result *= base")
        self._emit("    bit 0, E")
        self._emit("    jr z, _exp16_square")
        self._emit("    push DE")
        self._emit("    push BC")
        self._emit("    ld D, B")
        self._emit("    ld E, C")
        self._emit("    call _mul16")
        self._emit("    pop BC")
        self._emit("    pop DE")
        self._emit("_exp16_square:")
        self._emit("    ; base *= base")
        self._emit("    push HL")
        self._emit("    ld H, B")
        self._emit("    ld L, C")
        self._emit("    ld D, B")
        self._emit("    ld E, C")
        self._emit("    call _mul16")
        self._emit("    ld B, H")
        self._emit("    ld C, L")
        self._emit("    pop HL")
        self._emit("    ; exp /= 2")
        self._emit("    srl D")
        self._emit("    rr E")
        self._emit("    jr _exp16_loop")
        self._emit("_exp16_done:")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")

    def _generate_text_io_runtime(self) -> None:
        """Generate Text_IO runtime for CP/M BDOS."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Ada.Text_IO Runtime for CP/M")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; CP/M BDOS entry point")
        self._emit("BDOS: equ 5")
        self._emit("")
        self._emit("; _put_char: Output single character")
        self._emit("; Input: A = character to output")
        self._emit("_put_char:")
        self._emit("    ld E, A")
        self._emit("    ld C, 2      ; BDOS function 2: console output")
        self._emit("    call BDOS")
        self._emit("    ret")
        self._emit("")
        self._emit("; _put_string: Output null-terminated string")
        self._emit("; Input: HL = pointer to string")
        self._emit("_put_string:")
        self._emit("    push HL")
        self._emit("_put_string_loop:")
        self._emit("    ld A, (HL)")
        self._emit("    or A")
        self._emit("    jr z, _put_string_done")
        self._emit("    call _put_char")
        self._emit("    inc HL")
        self._emit("    jr _put_string_loop")
        self._emit("_put_string_done:")
        self._emit("    pop HL")
        self._emit("    ret")
        self._emit("")
        self._emit("; _put_line: Output string followed by CR+LF")
        self._emit("; Input: Stack: pointer to string")
        self._emit("_put_line:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get string pointer from stack (at IX+4)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    call _put_string")
        self._emit("    call _new_line")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _new_line: Output CR+LF")
        self._emit("_new_line:")
        self._emit("    ld A, 13     ; CR")
        self._emit("    call _put_char")
        self._emit("    ld A, 10     ; LF")
        self._emit("    call _put_char")
        self._emit("    ret")
        self._emit("")
        self._emit("; _put_int: Output integer (calls _int_to_str then _put_string)")
        self._emit("; Input: Stack: value (16-bit signed)")
        self._emit("_put_int:")
        self._emit("    ; Convert integer to string first")
        self._emit("    call _int_to_str")
        self._emit("    ; HL now contains pointer to string")
        self._emit("    call _put_string")
        self._emit("    ret")
        self._emit("")
        self._emit("; _put_int_line: Output integer followed by CR+LF")
        self._emit("; Input: Stack: value (16-bit signed)")
        self._emit("_put_int_line:")
        self._emit("    call _int_to_str")
        self._emit("    call _put_string")
        self._emit("    call _new_line")
        self._emit("    ret")
        self._emit("")
        self._emit("; _get_char: Get single character from console")
        self._emit("; Output: A = character read, HL = character (zero-extended)")
        self._emit("_get_char:")
        self._emit("    ld C, 1      ; BDOS function 1: console input")
        self._emit("    call BDOS")
        self._emit("    ld L, A")
        self._emit("    ld H, 0")
        self._emit("    ret")
        self._emit("")
        self._emit("; _get_line: Read line from console into buffer")
        self._emit("; Input: HL = buffer address, DE = max length")
        self._emit("; Output: HL = actual length read")
        self._emit("_get_line:")
        self._emit("    push DE      ; save max length")
        self._emit("    push HL      ; save buffer address")
        self._emit("    ld B, 0      ; length counter")
        self._emit("_get_line_loop:")
        self._emit("    call _get_char")
        self._emit("    ; Check for CR (end of line)")
        self._emit("    cp 13")
        self._emit("    jr z, _get_line_done")
        self._emit("    ; Check for max length")
        self._emit("    ld A, E      ; max length low")
        self._emit("    cp B")
        self._emit("    jr z, _get_line_done  ; buffer full")
        self._emit("    ; Store character")
        self._emit("    ld A, L")
        self._emit("    call _get_char  ; re-read (simplified)")
        self._emit("    pop HL")
        self._emit("    push HL")
        self._emit("    ld (HL), A")
        self._emit("    inc HL")
        self._emit("    inc B")
        self._emit("    jr _get_line_loop")
        self._emit("_get_line_done:")
        self._emit("    pop HL       ; discard buffer address")
        self._emit("    pop DE       ; discard max length")
        self._emit("    ld L, B")
        self._emit("    ld H, 0      ; HL = actual length")
        self._emit("    ret")
        self._emit("")

    def _generate_dispatch_runtime(self) -> None:
        """Generate runtime for OOP dispatching."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; OOP Dispatch Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; _dispatch_call: Call procedure whose address is in HL")
        self._emit("; This is needed because Z80 has no 'call (HL)' instruction")
        self._emit("; We use self-modifying code or a jump trampoline")
        self._emit("_dispatch_call:")
        self._emit("    jp (HL)      ; Jump to target (caller's return addr is on stack)")
        self._emit("")
        self._generate_z80_specific_runtime()
        self._generate_cpm_specific_runtime()
        self._generate_memory_runtime()

    def _generate_z80_specific_runtime(self) -> None:
        """Generate Z80-specific runtime functions for low-level access."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Z80-Specific Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; _port_in: Read from I/O port")
        self._emit("; Input: Stack: port number (8-bit)")
        self._emit("; Output: HL = value read")
        self._emit("_port_in:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ld C, (IX+4)  ; port number")
        self._emit("    in A, (C)")
        self._emit("    ld L, A")
        self._emit("    ld H, 0")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _port_out: Write to I/O port")
        self._emit("; Input: Stack: port number, value")
        self._emit("_port_out:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ld C, (IX+4)  ; port number")
        self._emit("    ld A, (IX+6)  ; value")
        self._emit("    out (C), A")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _get_interrupt_state: Check if interrupts enabled")
        self._emit("; Output: HL = 1 if enabled, 0 if disabled")
        self._emit("; Note: Z80 has no direct way to read IFF, use shadow")
        self._emit("_get_interrupt_state:")
        self._emit("    ld HL, (_int_enabled_flag)")
        self._emit("    ret")
        self._emit("")
        self._emit("; Interrupt enable flag (shadow register)")
        self._emit("_int_enabled_flag: dw 1")
        self._emit("")
        self._emit("; _enable_interrupts: Enable interrupts")
        self._emit("_enable_interrupts:")
        self._emit("    ei")
        self._emit("    ld HL, 1")
        self._emit("    ld (_int_enabled_flag), HL")
        self._emit("    ret")
        self._emit("")
        self._emit("; _disable_interrupts: Disable interrupts")
        self._emit("_disable_interrupts:")
        self._emit("    di")
        self._emit("    ld HL, 0")
        self._emit("    ld (_int_enabled_flag), HL")
        self._emit("    ret")
        self._emit("")

    def _generate_cpm_specific_runtime(self) -> None:
        """Generate CP/M-specific runtime functions."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; CP/M-Specific Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; _bdos: Make BDOS system call")
        self._emit("; Input: Stack: function number, parameter (DE)")
        self._emit("; Output: HL = result (from A or HL depending on function)")
        self._emit("_bdos:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ld C, (IX+4)  ; function number")
        self._emit("    ld E, (IX+6)  ; parameter low")
        self._emit("    ld D, (IX+7)  ; parameter high")
        self._emit("    call 5        ; BDOS entry")
        self._emit("    ; Result in A (or BA for some functions)")
        self._emit("    ld L, A")
        self._emit("    ld H, B")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _bios: Make BIOS system call")
        self._emit("; Input: Stack: function number (0-16)")
        self._emit("; Output: HL = result")
        self._emit("_bios:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get BIOS jump table address from 0x0001")
        self._emit("    ld HL, (1)")
        self._emit("    ; Calculate offset: function * 3")
        self._emit("    ld A, (IX+4)  ; function number")
        self._emit("    ld E, A")
        self._emit("    add A, A      ; *2")
        self._emit("    add A, E      ; *3")
        self._emit("    ld E, A")
        self._emit("    ld D, 0")
        self._emit("    add HL, DE")
        self._emit("    ; Jump to BIOS routine")
        self._emit("    jp (HL)")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; DMA address tracking")
        self._emit("_dma_address: dw 0x0080  ; Default DMA at 0x80")
        self._emit("")

    def _generate_memory_runtime(self) -> None:
        """Generate memory management runtime functions."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Memory Management Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; _get_heap_size: Get current heap size")
        self._emit("; Output: HL = heap size in bytes")
        self._emit("_get_heap_size:")
        self._emit("    ld HL, (_heap_top)")
        self._emit("    ld DE, (_heap_start)")
        self._emit("    or A")
        self._emit("    sbc HL, DE")
        self._emit("    ret")
        self._emit("")
        self._emit("; _get_stack_size: Get current stack usage")
        self._emit("; Output: HL = bytes used on stack")
        self._emit("_get_stack_size:")
        self._emit("    ld HL, (_stack_top)")
        self._emit("    ld DE, 0")
        self._emit("    add HL, SP    ; Approximate - SP is current")
        self._emit("    ret")
        self._emit("")
        self._emit("; _get_free_memory: Get available free memory")
        self._emit("; Output: HL = free bytes between heap and stack")
        self._emit("_get_free_memory:")
        self._emit("    ; Free = SP - heap_top")
        self._emit("    ld HL, 0")
        self._emit("    add HL, SP")
        self._emit("    ld DE, (_heap_top)")
        self._emit("    or A")
        self._emit("    sbc HL, DE")
        self._emit("    ret")
        self._emit("")
        self._emit("; Memory management variables")
        self._emit("_heap_start: dw _heap_begin")
        self._emit("_heap_top:   dw _heap_begin")
        self._emit("_stack_top:  dw 0xFFFF  ; Will be set at startup")
        self._emit("")
        self._emit("; _get_tag_info: Get tag info structure for tagged type")
        self._emit("; Input: Stack: tag value")
        self._emit("; Output: HL = pointer to tag info")
        self._emit("_get_tag_info:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ; Tag points to vtable, first entry is tag info")
        self._emit("    ; Return tag itself as simplified tag info")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")

    def _generate_fixed_point_runtime(self) -> None:
        """Generate 32-bit fixed-point arithmetic runtime (16.16 format)."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Fixed-Point Arithmetic Runtime (16.16)")
        self._emit("; =========================================")
        self._emit("; Numbers are stored as 32-bit values:")
        self._emit("; High word = integer part + sign")
        self._emit("; Low word = fractional part (65536ths)")
        self._emit("")
        self._emit("; _fix_add: Add two 32-bit fixed-point numbers")
        self._emit("; Input: Stack: a_hi, a_lo, b_hi, b_lo")
        self._emit("; Output: HL = result_hi, DE = result_lo")
        self._emit("_fix_add:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get a_lo (IX+4) and b_lo (IX+8)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ld E, (IX+8)")
        self._emit("    ld D, (IX+9)")
        self._emit("    add HL, DE")
        self._emit("    push HL     ; save result_lo")
        self._emit("    ; Get a_hi (IX+6) and b_hi (IX+10)")
        self._emit("    ld L, (IX+6)")
        self._emit("    ld H, (IX+7)")
        self._emit("    ld E, (IX+10)")
        self._emit("    ld D, (IX+11)")
        self._emit("    adc HL, DE  ; add with carry from low add")
        self._emit("    pop DE      ; result_lo in DE")
        self._emit("    ; HL = result_hi, DE = result_lo")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fix_sub: Subtract two 32-bit fixed-point numbers (a - b)")
        self._emit("; Input: Stack: a_hi, a_lo, b_hi, b_lo")
        self._emit("; Output: HL = result_hi, DE = result_lo")
        self._emit("_fix_sub:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get a_lo (IX+4) and b_lo (IX+8)")
        self._emit("    ld L, (IX+4)")
        self._emit("    ld H, (IX+5)")
        self._emit("    ld E, (IX+8)")
        self._emit("    ld D, (IX+9)")
        self._emit("    or A        ; clear carry")
        self._emit("    sbc HL, DE")
        self._emit("    push HL     ; save result_lo")
        self._emit("    ; Get a_hi (IX+6) and b_hi (IX+10)")
        self._emit("    ld L, (IX+6)")
        self._emit("    ld H, (IX+7)")
        self._emit("    ld E, (IX+10)")
        self._emit("    ld D, (IX+11)")
        self._emit("    sbc HL, DE  ; sub with borrow from low sub")
        self._emit("    pop DE      ; result_lo in DE")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fix_mul: Multiply two 16.16 fixed-point numbers")
        self._emit("; Input: Stack: a_hi, a_lo, b_hi, b_lo")
        self._emit("; Output: HL = result_hi, DE = result_lo")
        self._emit("; Simplified: uses 16x16->32 multiply, handles only small values")
        self._emit("_fix_mul:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; For 16.16 * 16.16 we need 64-bit intermediate")
        self._emit("    ; Simplified: just multiply integer parts for now")
        self._emit("    ld L, (IX+6)  ; a_hi")
        self._emit("    ld H, (IX+7)")
        self._emit("    ld E, (IX+10) ; b_hi")
        self._emit("    ld D, (IX+11)")
        self._emit("    call _mul16")
        self._emit("    ; Result in HL, put in result_hi")
        self._emit("    ld D, 0")
        self._emit("    ld E, 0       ; result_lo = 0 (simplified)")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fix_div: Divide two 16.16 fixed-point numbers (a / b)")
        self._emit("; Input: Stack: a_hi, a_lo, b_hi, b_lo")
        self._emit("; Output: HL = result_hi, DE = result_lo")
        self._emit("_fix_div:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Simplified: divide integer parts only")
        self._emit("    ld L, (IX+6)  ; a_hi")
        self._emit("    ld H, (IX+7)")
        self._emit("    ld E, (IX+10) ; b_hi")
        self._emit("    ld D, (IX+11)")
        self._emit("    call _div16")
        self._emit("    ; Result in HL, put in result_hi")
        self._emit("    ld D, 0")
        self._emit("    ld E, 0       ; result_lo = 0 (simplified)")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fix_to_int: Convert 16.16 fixed-point to integer (truncate)")
        self._emit("; Input: HL = hi word, DE = lo word")
        self._emit("; Output: HL = integer value")
        self._emit("_fix_to_int:")
        self._emit("    ; Just return the high word (integer part)")
        self._emit("    ret")
        self._emit("")
        self._emit("; _int_to_fix: Convert integer to 16.16 fixed-point")
        self._emit("; Input: HL = integer value")
        self._emit("; Output: HL = hi word, DE = lo word (0)")
        self._emit("_int_to_fix:")
        self._emit("    ld DE, 0     ; fractional part = 0")
        self._emit("    ret")
        self._emit("")
        self._emit("; _fix_to_str: Convert 16.16 fixed-point to string")
        self._emit("; Input: Stack: hi_word, lo_word")
        self._emit("; Output: HL = pointer to string")
        self._emit("_fix_to_str:")
        self._emit("    push IX")
        self._emit("    ld IX, 0")
        self._emit("    add IX, SP")
        self._emit("    ; Get high word (integer part)")
        self._emit("    ld L, (IX+6)")
        self._emit("    ld H, (IX+7)")
        self._emit("    ; Convert integer part to string")
        self._emit("    push HL")
        self._emit("    call _int_to_str")
        self._emit("    ; For now, just return integer part string")
        self._emit("    ; Full implementation would append decimal point and fraction")
        self._emit("    pop BC       ; discard pushed arg")
        self._emit("    pop IX")
        self._emit("    ret")
        self._emit("")

    def _emit(self, line: str) -> None:
        """Emit a line of assembly."""
        self.output.append(line)

    def _emit_instr(self, mnemonic: str, *operands: str) -> None:
        """Emit an instruction."""
        if operands:
            self._emit(f"    {mnemonic} {', '.join(operands)}")
        else:
            self._emit(f"    {mnemonic}")

    def _generate_function(self, func: IRFunction) -> None:
        """Generate code for a function."""
        self.current_function = func

        # Allocate registers
        self.reg_alloc = self._allocate_registers(func)

        # Function prologue
        self._emit(f"; Function: {func.name}")
        self._emit(f"{func.name}:")

        # Set up stack frame
        if func.locals_size > 0 or self.reg_alloc.stack_size > 0:
            total_stack = func.locals_size + self.reg_alloc.stack_size
            self._emit_instr("push", "IX")
            self._emit_instr("ld", "IX", "0")
            self._emit_instr("add", "IX", "SP")
            if total_stack > 0:
                # Reserve stack space
                self._emit_instr("ld", "HL", str(-total_stack))
                self._emit_instr("add", "HL", "SP")
                self._emit_instr("ld", "SP", "HL")

        # Generate code for each block
        for block in func.blocks:
            self._generate_block(block)

        self._emit("")

    def _allocate_registers(self, func: IRFunction) -> RegisterAllocation:
        """Simple register allocation - spill everything to stack."""
        alloc = RegisterAllocation()

        # Collect all virtual registers
        vregs: set[int] = set()
        for block in func.blocks:
            for instr in block.instructions:
                for operand in [instr.dst, instr.src1, instr.src2]:
                    if isinstance(operand, VReg):
                        vregs.add(operand.id)

        # Allocate stack slots for each vreg
        offset = 0
        for vreg_id in sorted(vregs):
            alloc.vreg_to_stack[vreg_id] = offset
            offset += 2  # All values are 2 bytes for simplicity

        alloc.stack_size = offset
        return alloc

    def _generate_block(self, block: BasicBlock) -> None:
        """Generate code for a basic block."""
        self._emit(f"{block.label}:")

        for instr in block.instructions:
            self._generate_instr(instr)

    def _generate_instr(self, instr: IRInstr) -> None:
        """Generate code for an IR instruction."""
        # Add comment if present
        if instr.comment:
            self._emit(f"    ; {instr.comment}")

        op = instr.opcode

        if op == OpCode.MOV:
            self._gen_mov(instr)
        elif op == OpCode.LOAD:
            self._gen_load(instr)
        elif op == OpCode.STORE:
            self._gen_store(instr)
        elif op == OpCode.ADD:
            self._gen_add(instr)
        elif op == OpCode.SUB:
            self._gen_sub(instr)
        elif op == OpCode.MUL:
            self._gen_mul(instr)
        elif op == OpCode.DIV:
            self._gen_div(instr)
        elif op == OpCode.MOD:
            self._gen_mod(instr)
        elif op == OpCode.REM:
            self._gen_rem(instr)
        elif op == OpCode.NEG:
            self._gen_neg(instr)
        elif op == OpCode.AND:
            self._gen_and(instr)
        elif op == OpCode.OR:
            self._gen_or(instr)
        elif op == OpCode.XOR:
            self._gen_xor(instr)
        elif op == OpCode.NOT:
            self._gen_not(instr)
        elif op == OpCode.SHL:
            self._gen_shl(instr)
        elif op == OpCode.SHR:
            self._gen_shr(instr)
        elif op in (OpCode.CMP_EQ, OpCode.CMP_NE, OpCode.CMP_LT,
                    OpCode.CMP_LE, OpCode.CMP_GT, OpCode.CMP_GE):
            self._gen_cmp(instr)
        elif op == OpCode.JMP:
            self._gen_jmp(instr)
        elif op == OpCode.JZ:
            self._gen_jz(instr)
        elif op == OpCode.JNZ:
            self._gen_jnz(instr)
        elif op == OpCode.CALL:
            self._gen_call(instr)
        elif op == OpCode.CALL_INDIRECT:
            self._gen_call_indirect(instr)
        elif op == OpCode.DISPATCH:
            self._gen_dispatch(instr)
        elif op == OpCode.RET:
            self._gen_ret(instr)
        elif op == OpCode.PUSH:
            self._gen_push(instr)
        elif op == OpCode.POP:
            self._gen_pop(instr)
        elif op == OpCode.LABEL:
            pass  # Labels are handled in block generation
        elif op == OpCode.LEA:
            self._gen_lea(instr)
        elif op == OpCode.NOP:
            self._emit_instr("nop")
        # Exception handling
        elif op == OpCode.EXC_PUSH:
            self._gen_exc_push(instr)
        elif op == OpCode.EXC_POP:
            self._gen_exc_pop(instr)
        elif op == OpCode.EXC_RAISE:
            self._gen_exc_raise(instr)
        elif op == OpCode.EXC_RERAISE:
            self._gen_exc_reraise(instr)

    def _load_to_hl(self, value: IRValue) -> None:
        """Load a value into HL."""
        if isinstance(value, Immediate):
            self._emit_instr("ld", "HL", str(value.value))
        elif isinstance(value, VReg):
            offset = self._vreg_offset(value)
            self._emit_instr("ld", "L", f"(IX{offset:+d})")
            self._emit_instr("ld", "H", f"(IX{offset+1:+d})")
        elif isinstance(value, Label):
            self._emit_instr("ld", "HL", value.name)

    def _load_to_de(self, value: IRValue) -> None:
        """Load a value into DE."""
        if isinstance(value, Immediate):
            self._emit_instr("ld", "DE", str(value.value))
        elif isinstance(value, VReg):
            offset = self._vreg_offset(value)
            self._emit_instr("ld", "E", f"(IX{offset:+d})")
            self._emit_instr("ld", "D", f"(IX{offset+1:+d})")
        elif isinstance(value, Label):
            self._emit_instr("ld", "DE", value.name)

    def _load_to_a(self, value: IRValue) -> None:
        """Load a byte value into A."""
        if isinstance(value, Immediate):
            self._emit_instr("ld", "A", str(value.value & 0xFF))
        elif isinstance(value, VReg):
            offset = self._vreg_offset(value)
            self._emit_instr("ld", "A", f"(IX{offset:+d})")

    def _store_from_hl(self, dst: VReg) -> None:
        """Store HL to a vreg."""
        offset = self._vreg_offset(dst)
        self._emit_instr("ld", f"(IX{offset:+d})", "L")
        self._emit_instr("ld", f"(IX{offset+1:+d})", "H")

    def _store_from_a(self, dst: VReg) -> None:
        """Store A to a vreg (byte)."""
        offset = self._vreg_offset(dst)
        self._emit_instr("ld", f"(IX{offset:+d})", "A")

    def _vreg_offset(self, vreg: VReg) -> int:
        """Get the stack offset for a virtual register."""
        if self.reg_alloc and vreg.id in self.reg_alloc.vreg_to_stack:
            # Negative offset from IX (local variables)
            return -(self.reg_alloc.vreg_to_stack[vreg.id] + 2)
        return 0

    # Instruction generators

    def _gen_mov(self, instr: IRInstr) -> None:
        """Generate MOV instruction."""
        if not isinstance(instr.dst, VReg) or instr.src1 is None:
            return
        self._load_to_hl(instr.src1)
        self._store_from_hl(instr.dst)

    def _gen_load(self, instr: IRInstr) -> None:
        """Generate LOAD instruction."""
        if not isinstance(instr.dst, VReg) or not isinstance(instr.src1, MemoryLocation):
            return

        mem = instr.src1
        if mem.is_global:
            self._emit_instr("ld", "HL", f"({mem.symbol_name})")
        elif mem.base is not None:
            # Load from computed address: base + offset
            # First load the base address into HL
            self._load_to_hl(mem.base)
            if mem.offset != 0:
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")
            # Now load the value at (HL)
            self._emit_instr("ld", "E", "(HL)")
            self._emit_instr("inc", "HL")
            self._emit_instr("ld", "D", "(HL)")
            self._emit_instr("ex", "DE", "HL")
        else:
            # Load from stack-relative address
            self._emit_instr("ld", "L", f"(IX{mem.offset:+d})")
            self._emit_instr("ld", "H", f"(IX{mem.offset+1:+d})")

        self._store_from_hl(instr.dst)

    def _gen_store(self, instr: IRInstr) -> None:
        """Generate STORE instruction."""
        if not isinstance(instr.dst, MemoryLocation) or instr.src1 is None:
            return

        mem = instr.dst

        if mem.is_global:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", f"({mem.symbol_name})", "HL")
        elif mem.base is not None:
            # Store to computed address: base + offset
            # Load value into DE first
            self._load_to_de(instr.src1)
            # Load address into HL
            self._load_to_hl(mem.base)
            if mem.offset != 0:
                self._emit_instr("push", "DE")  # Save value
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")
                self._emit_instr("pop", "DE")  # Restore value
            # Store DE to (HL)
            self._emit_instr("ld", "(HL)", "E")
            self._emit_instr("inc", "HL")
            self._emit_instr("ld", "(HL)", "D")
        else:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", f"(IX{mem.offset:+d})", "L")
            self._emit_instr("ld", f"(IX{mem.offset+1:+d})", "H")

    def _gen_lea(self, instr: IRInstr) -> None:
        """Generate LEA (load effective address) instruction."""
        if not isinstance(instr.dst, VReg) or not isinstance(instr.src1, MemoryLocation):
            return

        mem = instr.src1
        if mem.is_global:
            # Load address of global variable
            self._emit_instr("ld", "HL", mem.symbol_name)
        elif mem.base is not None:
            # Computed address: base + offset
            self._load_to_hl(mem.base)
            if mem.offset != 0:
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")
        else:
            # Stack-relative address: IX + offset
            self._emit_instr("push", "IX")
            self._emit_instr("pop", "HL")
            if mem.offset != 0:
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")

        self._store_from_hl(instr.dst)

    def _gen_add(self, instr: IRInstr) -> None:
        """Generate ADD instruction."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("add", "HL", "DE")
        self._store_from_hl(instr.dst)

    def _gen_sub(self, instr: IRInstr) -> None:
        """Generate SUB instruction."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("or", "A")  # Clear carry
        self._emit_instr("sbc", "HL", "DE")
        self._store_from_hl(instr.dst)

    def _gen_mul(self, instr: IRInstr) -> None:
        """Generate MUL instruction (16-bit multiply via subroutine)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("call", "_mul16")
        self._store_from_hl(instr.dst)

    def _gen_div(self, instr: IRInstr) -> None:
        """Generate DIV instruction (16-bit divide via subroutine)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("call", "_div16")
        self._store_from_hl(instr.dst)

    def _gen_mod(self, instr: IRInstr) -> None:
        """Generate MOD instruction (16-bit modulo via subroutine)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("call", "_mod16")
        self._store_from_hl(instr.dst)

    def _gen_rem(self, instr: IRInstr) -> None:
        """Generate REM instruction (16-bit remainder via subroutine)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("call", "_rem16")
        self._store_from_hl(instr.dst)

    def _gen_neg(self, instr: IRInstr) -> None:
        """Generate NEG instruction."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        # Negate HL: HL = 0 - HL
        self._emit_instr("xor", "A")
        self._emit_instr("sub", "L")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("sbc", "A", "A")
        self._emit_instr("sub", "H")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_and(self, instr: IRInstr) -> None:
        """Generate AND instruction (16-bit)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("and", "E")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("and", "D")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_or(self, instr: IRInstr) -> None:
        """Generate OR instruction (16-bit)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("or", "E")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("or", "D")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_xor(self, instr: IRInstr) -> None:
        """Generate XOR instruction (16-bit)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("xor", "E")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("xor", "D")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_not(self, instr: IRInstr) -> None:
        """Generate NOT instruction (16-bit complement)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("cpl")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("cpl")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_shl(self, instr: IRInstr) -> None:
        """Generate SHL instruction (16-bit left shift)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        # Call shift left runtime
        self._emit_instr("call", "_shl16")
        self._store_from_hl(instr.dst)

    def _gen_shr(self, instr: IRInstr) -> None:
        """Generate SHR instruction (16-bit right shift, unsigned)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        # Call shift right runtime
        self._emit_instr("call", "_shr16")
        self._store_from_hl(instr.dst)

    def _gen_cmp(self, instr: IRInstr) -> None:
        """Generate comparison instruction."""
        if not isinstance(instr.dst, VReg):
            return

        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)

        # Compare HL with DE
        self._emit_instr("or", "A")  # Clear carry
        self._emit_instr("sbc", "HL", "DE")

        # Set result based on comparison type
        op = instr.opcode
        if op == OpCode.CMP_EQ:
            # Result = 1 if Z flag set
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jr", "NZ", "$+3")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_NE:
            # Result = 1 if Z flag not set
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jr", "Z", "$+3")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_LT:
            # Result = 1 if S flag set (negative result, signed)
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jp", "P", "$+4")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_GE:
            # Result = 1 if S flag not set (non-negative, signed)
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jp", "M", "$+4")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_GT:
            # GT: not (LT or EQ) - more complex
            self._emit_instr("ld", "HL", "1")
            self._emit_instr("jp", "M", "$+6")
            self._emit_instr("jr", "Z", "$+4")
            self._emit_instr("jr", "$+3")
            self._emit_instr("dec", "L")
        elif op == OpCode.CMP_LE:
            # LE: LT or EQ
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jp", "M", "$+4")
            self._emit_instr("jr", "NZ", "$+3")
            self._emit_instr("inc", "L")

        self._store_from_hl(instr.dst)

    def _gen_jmp(self, instr: IRInstr) -> None:
        """Generate JMP instruction."""
        if isinstance(instr.dst, Label):
            self._emit_instr("jp", instr.dst.name)

    def _gen_jz(self, instr: IRInstr) -> None:
        """Generate JZ (jump if zero) instruction."""
        if isinstance(instr.dst, Label) and instr.src1:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", "A", "H")
            self._emit_instr("or", "L")
            self._emit_instr("jp", "Z", instr.dst.name)

    def _gen_jnz(self, instr: IRInstr) -> None:
        """Generate JNZ (jump if not zero) instruction."""
        if isinstance(instr.dst, Label) and instr.src1:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", "A", "H")
            self._emit_instr("or", "L")
            self._emit_instr("jp", "NZ", instr.dst.name)

    def _gen_call(self, instr: IRInstr) -> None:
        """Generate CALL instruction."""
        if isinstance(instr.dst, Label):
            self._emit_instr("call", instr.dst.name)

    def _gen_call_indirect(self, instr: IRInstr) -> None:
        """Generate indirect CALL through function pointer.

        src1 = function pointer (address to call)
        Uses _dispatch_call helper which expects address in HL.
        """
        # Load function pointer into HL
        self._load_to_hl(instr.src1)
        # Call through HL using the dispatch helper
        self._emit_instr("call", "_dispatch_call")

    def _gen_dispatch(self, instr: IRInstr) -> None:
        """Generate dispatching call through vtable.

        src1 = object (pointer to tagged record, tag is at offset 0)
        src2 = slot index in vtable
        """
        # Load object pointer to get tag (vtable pointer)
        self._load_to_hl(instr.src1)
        # HL now points to object, dereference to get vtable ptr
        self._emit_instr("ld", "E", "(HL)")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "D", "(HL)")
        # DE now has vtable pointer

        # Calculate offset in vtable: slot * 2 (each entry is 2 bytes)
        if isinstance(instr.src2, Immediate):
            slot_offset = instr.src2.value * 2
            if slot_offset > 0:
                self._emit_instr("ld", "HL", str(slot_offset))
                self._emit_instr("add", "HL", "DE")
                self._emit_instr("ex", "DE", "HL")
        # DE now points to vtable entry

        # Load the target address from vtable
        self._emit_instr("ex", "DE", "HL")
        self._emit_instr("ld", "E", "(HL)")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "D", "(HL)")
        # DE now has target procedure address

        # Call through DE using jp (DE) via helper
        self._emit_instr("ex", "DE", "HL")
        self._emit_instr("call", "_dispatch_call")

    def _gen_ret(self, instr: IRInstr) -> None:
        """Generate RET instruction."""
        # Put return value in HL if present
        if instr.src1:
            self._load_to_hl(instr.src1)

        # Epilogue
        if self.current_function:
            total_stack = (self.current_function.locals_size +
                          (self.reg_alloc.stack_size if self.reg_alloc else 0))
            if total_stack > 0:
                self._emit_instr("ld", "SP", "IX")
                self._emit_instr("pop", "IX")
            else:
                self._emit_instr("pop", "IX")

        self._emit_instr("ret")

    def _gen_push(self, instr: IRInstr) -> None:
        """Generate PUSH instruction."""
        if instr.src1:
            self._load_to_hl(instr.src1)
            self._emit_instr("push", "HL")

    def _gen_pop(self, instr: IRInstr) -> None:
        """Generate POP instruction."""
        if isinstance(instr.dst, VReg):
            self._emit_instr("pop", "HL")
            self._store_from_hl(instr.dst)

    # =========================================================================
    # Exception Handling
    # =========================================================================
    #
    # Runtime exception handling uses a linked list of handler frames.
    # Global variables:
    #   _exc_handler:  current handler chain head (pointer)
    #   _exc_current:  currently raised exception ID
    #   _exc_message:  exception message pointer (or 0)
    #
    # Handler frame structure (8 bytes):
    #   +0: previous handler pointer (2 bytes)
    #   +2: saved SP (2 bytes)
    #   +4: handler address (2 bytes)
    #   +6: exception ID to catch (2 bytes, 0 = catch all)

    def _gen_exc_push(self, instr: IRInstr) -> None:
        """Generate exception handler push.

        dst = handler label, src1 = exception ID to catch
        """
        self._emit(f"    ; push exception handler")

        # Get handler address
        if isinstance(instr.dst, Label):
            handler_addr = instr.dst.name
        else:
            return

        # Get exception ID
        exc_id = 0
        if isinstance(instr.src1, Immediate):
            exc_id = instr.src1.value

        # Allocate 8 bytes for handler frame on stack
        self._emit_instr("ld", "HL", "-8")
        self._emit_instr("add", "HL", "SP")
        self._emit_instr("ld", "SP", "HL")

        # Store previous handler pointer at +0
        self._emit_instr("ld", "DE", "(_exc_handler)")
        self._emit_instr("ld", "(HL)", "E")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "(HL)", "D")
        self._emit_instr("inc", "HL")

        # Store saved SP at +2 (SP before the frame allocation + 8)
        self._emit_instr("push", "HL")  # Save HL
        self._emit_instr("ld", "HL", "10")  # 8 bytes + 2 for push HL
        self._emit_instr("add", "HL", "SP")
        self._emit_instr("ld", "D", "H")
        self._emit_instr("ld", "E", "L")
        self._emit_instr("pop", "HL")  # Restore HL
        self._emit_instr("ld", "(HL)", "E")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "(HL)", "D")
        self._emit_instr("inc", "HL")

        # Store handler address at +4
        self._emit_instr("ld", "DE", handler_addr)
        self._emit_instr("ld", "(HL)", "E")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "(HL)", "D")
        self._emit_instr("inc", "HL")

        # Store exception ID at +6
        self._emit_instr("ld", "DE", str(exc_id))
        self._emit_instr("ld", "(HL)", "E")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "(HL)", "D")

        # Update _exc_handler to point to new frame
        self._emit_instr("ld", "HL", "0")
        self._emit_instr("add", "HL", "SP")
        self._emit_instr("ld", "(_exc_handler)", "HL")

    def _gen_exc_pop(self, instr: IRInstr) -> None:
        """Generate exception handler pop (normal exit)."""
        self._emit(f"    ; pop exception handler")

        # Get previous handler from frame
        self._emit_instr("ld", "HL", "(_exc_handler)")
        self._emit_instr("ld", "E", "(HL)")
        self._emit_instr("inc", "HL")
        self._emit_instr("ld", "D", "(HL)")

        # Restore _exc_handler
        self._emit_instr("ld", "(_exc_handler)", "DE")

        # Deallocate frame (8 bytes)
        self._emit_instr("ld", "HL", "8")
        self._emit_instr("add", "HL", "SP")
        self._emit_instr("ld", "SP", "HL")

    def _gen_exc_raise(self, instr: IRInstr) -> None:
        """Generate raise exception.

        src1 = exception ID, src2 = message pointer (optional)
        """
        self._emit(f"    ; raise exception")

        # Store exception ID
        exc_id = 0
        if isinstance(instr.src1, Immediate):
            exc_id = instr.src1.value
        self._emit_instr("ld", "HL", str(exc_id))
        self._emit_instr("ld", "(_exc_current)", "HL")

        # Store message pointer (0 if none)
        if instr.src2:
            self._load_to_hl(instr.src2)
        else:
            self._emit_instr("ld", "HL", "0")
        self._emit_instr("ld", "(_exc_message)", "HL")

        # Call runtime raise routine
        self._emit_instr("call", "_exc_do_raise")

    def _gen_exc_reraise(self, instr: IRInstr) -> None:
        """Generate re-raise current exception."""
        self._emit(f"    ; reraise exception")
        # _exc_current and _exc_message already set
        self._emit_instr("call", "_exc_do_raise")


def generate_z80(module: IRModule) -> str:
    """Generate Z80 assembly from an IR module."""
    codegen = Z80CodeGen()
    return codegen.generate(module)
