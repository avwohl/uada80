"""
Z80 Code Generator.

Translates IR to Z80 assembly code.
"""

from dataclasses import dataclass, field
from typing import Optional

from uada80.ir import (
    IRModule,
    IRFunction,
    BasicBlock,
    IRInstr,
    OpCode,
    IRType,
    IRValue,
    VReg,
    Immediate,
    Label,
    MemoryLocation,
    ir_type_size,
)


@dataclass
class Z80Register:
    """Z80 register."""

    name: str
    is_16bit: bool = False


# Z80 registers
REG_A = Z80Register("A")
REG_B = Z80Register("B")
REG_C = Z80Register("C")
REG_D = Z80Register("D")
REG_E = Z80Register("E")
REG_H = Z80Register("H")
REG_L = Z80Register("L")
REG_BC = Z80Register("BC", True)
REG_DE = Z80Register("DE", True)
REG_HL = Z80Register("HL", True)
REG_SP = Z80Register("SP", True)
REG_IX = Z80Register("IX", True)
REG_IY = Z80Register("IY", True)


@dataclass
class RegisterAllocation:
    """Mapping of virtual registers to Z80 registers or stack slots."""

    vreg_to_reg: dict[int, Z80Register] = field(default_factory=dict)
    vreg_to_stack: dict[int, int] = field(default_factory=dict)  # stack offset
    stack_size: int = 0


class Z80CodeGen:
    """Z80 code generator."""

    def __init__(self) -> None:
        self.output: list[str] = []
        self.reg_alloc: Optional[RegisterAllocation] = None
        self.current_function: Optional[IRFunction] = None

    def generate(self, module: IRModule) -> str:
        """Generate Z80 assembly for an IR module."""
        self.output = []

        # Header
        self._emit("; Generated by uada80 Ada compiler")
        self._emit("; Target: Z80")
        self._emit("")

        # Generate globals
        if module.globals:
            self._emit("; Global variables")
            self._emit(".data")
            for name, (ir_type, size) in module.globals.items():
                self._emit(f"{name}:")
                self._emit(f"    .ds {size}")
            self._emit("")

        # Generate string literals
        if module.string_literals:
            self._emit("; String literals")
            for label, value in module.string_literals.items():
                escaped = value.replace('"', '\\"')
                self._emit(f'{label}:')
                self._emit(f'    .db "{escaped}", 0')
            self._emit("")

        # Generate code
        self._emit(".code")
        self._emit("")

        for func in module.functions:
            self._generate_function(func)

        # Generate heap runtime if needed
        self._generate_heap_runtime()

        return "\n".join(self.output)

    def _generate_heap_runtime(self) -> None:
        """Generate simple heap allocator runtime."""
        self._emit("")
        self._emit("; =========================================")
        self._emit("; Heap Runtime")
        self._emit("; =========================================")
        self._emit("")
        self._emit("; Heap pointer (grows upward from _heap_start)")
        self._emit("_heap_ptr:")
        self._emit("    .dw _heap_start")
        self._emit("")
        self._emit("; _heap_alloc: Allocate memory from heap")
        self._emit("; Input: HL = size to allocate")
        self._emit("; Output: HL = pointer to allocated memory (0 if failed)")
        self._emit("_heap_alloc:")
        self._emit("    push DE")
        self._emit("    push BC")
        self._emit("    ; Load current heap pointer")
        self._emit("    ld DE, (_heap_ptr)")
        self._emit("    ; Save current pointer as return value")
        self._emit("    push DE")
        self._emit("    ; Advance heap pointer by size (DE += HL)")
        self._emit("    add HL, DE")
        self._emit("    ; Check for overflow (HL >= _heap_end)")
        self._emit("    ld BC, _heap_end")
        self._emit("    or A")
        self._emit("    sbc HL, BC")
        self._emit("    add HL, BC  ; restore HL")
        self._emit("    jr nc, _heap_alloc_fail")
        self._emit("    ; Store new heap pointer")
        self._emit("    ld (_heap_ptr), HL")
        self._emit("    ; Return saved pointer")
        self._emit("    pop HL")
        self._emit("    pop BC")
        self._emit("    pop DE")
        self._emit("    ret")
        self._emit("_heap_alloc_fail:")
        self._emit("    ; Return null (0)")
        self._emit("    pop HL  ; discard saved pointer")
        self._emit("    ld HL, 0")
        self._emit("    pop BC")
        self._emit("    pop DE")
        self._emit("    ret")
        self._emit("")
        self._emit("; Heap area (adjust size as needed)")
        self._emit("_heap_start:")
        self._emit("    .ds 2048  ; 2KB heap")
        self._emit("_heap_end:")
        self._emit("")

    def _emit(self, line: str) -> None:
        """Emit a line of assembly."""
        self.output.append(line)

    def _emit_instr(self, mnemonic: str, *operands: str) -> None:
        """Emit an instruction."""
        if operands:
            self._emit(f"    {mnemonic} {', '.join(operands)}")
        else:
            self._emit(f"    {mnemonic}")

    def _generate_function(self, func: IRFunction) -> None:
        """Generate code for a function."""
        self.current_function = func

        # Allocate registers
        self.reg_alloc = self._allocate_registers(func)

        # Function prologue
        self._emit(f"; Function: {func.name}")
        self._emit(f"{func.name}:")

        # Set up stack frame
        if func.locals_size > 0 or self.reg_alloc.stack_size > 0:
            total_stack = func.locals_size + self.reg_alloc.stack_size
            self._emit_instr("push", "IX")
            self._emit_instr("ld", "IX", "0")
            self._emit_instr("add", "IX", "SP")
            if total_stack > 0:
                # Reserve stack space
                self._emit_instr("ld", "HL", str(-total_stack))
                self._emit_instr("add", "HL", "SP")
                self._emit_instr("ld", "SP", "HL")

        # Generate code for each block
        for block in func.blocks:
            self._generate_block(block)

        self._emit("")

    def _allocate_registers(self, func: IRFunction) -> RegisterAllocation:
        """Simple register allocation - spill everything to stack."""
        alloc = RegisterAllocation()

        # Collect all virtual registers
        vregs: set[int] = set()
        for block in func.blocks:
            for instr in block.instructions:
                for operand in [instr.dst, instr.src1, instr.src2]:
                    if isinstance(operand, VReg):
                        vregs.add(operand.id)

        # Allocate stack slots for each vreg
        offset = 0
        for vreg_id in sorted(vregs):
            alloc.vreg_to_stack[vreg_id] = offset
            offset += 2  # All values are 2 bytes for simplicity

        alloc.stack_size = offset
        return alloc

    def _generate_block(self, block: BasicBlock) -> None:
        """Generate code for a basic block."""
        self._emit(f"{block.label}:")

        for instr in block.instructions:
            self._generate_instr(instr)

    def _generate_instr(self, instr: IRInstr) -> None:
        """Generate code for an IR instruction."""
        # Add comment if present
        if instr.comment:
            self._emit(f"    ; {instr.comment}")

        op = instr.opcode

        if op == OpCode.MOV:
            self._gen_mov(instr)
        elif op == OpCode.LOAD:
            self._gen_load(instr)
        elif op == OpCode.STORE:
            self._gen_store(instr)
        elif op == OpCode.ADD:
            self._gen_add(instr)
        elif op == OpCode.SUB:
            self._gen_sub(instr)
        elif op == OpCode.MUL:
            self._gen_mul(instr)
        elif op == OpCode.DIV:
            self._gen_div(instr)
        elif op == OpCode.NEG:
            self._gen_neg(instr)
        elif op == OpCode.AND:
            self._gen_and(instr)
        elif op == OpCode.OR:
            self._gen_or(instr)
        elif op == OpCode.XOR:
            self._gen_xor(instr)
        elif op == OpCode.NOT:
            self._gen_not(instr)
        elif op in (OpCode.CMP_EQ, OpCode.CMP_NE, OpCode.CMP_LT,
                    OpCode.CMP_LE, OpCode.CMP_GT, OpCode.CMP_GE):
            self._gen_cmp(instr)
        elif op == OpCode.JMP:
            self._gen_jmp(instr)
        elif op == OpCode.JZ:
            self._gen_jz(instr)
        elif op == OpCode.JNZ:
            self._gen_jnz(instr)
        elif op == OpCode.CALL:
            self._gen_call(instr)
        elif op == OpCode.RET:
            self._gen_ret(instr)
        elif op == OpCode.PUSH:
            self._gen_push(instr)
        elif op == OpCode.POP:
            self._gen_pop(instr)
        elif op == OpCode.LABEL:
            pass  # Labels are handled in block generation
        elif op == OpCode.LEA:
            self._gen_lea(instr)
        elif op == OpCode.NOP:
            self._emit_instr("nop")

    def _load_to_hl(self, value: IRValue) -> None:
        """Load a value into HL."""
        if isinstance(value, Immediate):
            self._emit_instr("ld", "HL", str(value.value))
        elif isinstance(value, VReg):
            offset = self._vreg_offset(value)
            self._emit_instr("ld", "L", f"(IX{offset:+d})")
            self._emit_instr("ld", "H", f"(IX{offset+1:+d})")
        elif isinstance(value, Label):
            self._emit_instr("ld", "HL", value.name)

    def _load_to_de(self, value: IRValue) -> None:
        """Load a value into DE."""
        if isinstance(value, Immediate):
            self._emit_instr("ld", "DE", str(value.value))
        elif isinstance(value, VReg):
            offset = self._vreg_offset(value)
            self._emit_instr("ld", "E", f"(IX{offset:+d})")
            self._emit_instr("ld", "D", f"(IX{offset+1:+d})")
        elif isinstance(value, Label):
            self._emit_instr("ld", "DE", value.name)

    def _load_to_a(self, value: IRValue) -> None:
        """Load a byte value into A."""
        if isinstance(value, Immediate):
            self._emit_instr("ld", "A", str(value.value & 0xFF))
        elif isinstance(value, VReg):
            offset = self._vreg_offset(value)
            self._emit_instr("ld", "A", f"(IX{offset:+d})")

    def _store_from_hl(self, dst: VReg) -> None:
        """Store HL to a vreg."""
        offset = self._vreg_offset(dst)
        self._emit_instr("ld", f"(IX{offset:+d})", "L")
        self._emit_instr("ld", f"(IX{offset+1:+d})", "H")

    def _store_from_a(self, dst: VReg) -> None:
        """Store A to a vreg (byte)."""
        offset = self._vreg_offset(dst)
        self._emit_instr("ld", f"(IX{offset:+d})", "A")

    def _vreg_offset(self, vreg: VReg) -> int:
        """Get the stack offset for a virtual register."""
        if self.reg_alloc and vreg.id in self.reg_alloc.vreg_to_stack:
            # Negative offset from IX (local variables)
            return -(self.reg_alloc.vreg_to_stack[vreg.id] + 2)
        return 0

    # Instruction generators

    def _gen_mov(self, instr: IRInstr) -> None:
        """Generate MOV instruction."""
        if not isinstance(instr.dst, VReg) or instr.src1 is None:
            return
        self._load_to_hl(instr.src1)
        self._store_from_hl(instr.dst)

    def _gen_load(self, instr: IRInstr) -> None:
        """Generate LOAD instruction."""
        if not isinstance(instr.dst, VReg) or not isinstance(instr.src1, MemoryLocation):
            return

        mem = instr.src1
        if mem.is_global:
            self._emit_instr("ld", "HL", f"({mem.symbol_name})")
        elif mem.base is not None:
            # Load from computed address: base + offset
            # First load the base address into HL
            self._load_to_hl(mem.base)
            if mem.offset != 0:
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")
            # Now load the value at (HL)
            self._emit_instr("ld", "E", "(HL)")
            self._emit_instr("inc", "HL")
            self._emit_instr("ld", "D", "(HL)")
            self._emit_instr("ex", "DE", "HL")
        else:
            # Load from stack-relative address
            self._emit_instr("ld", "L", f"(IX{mem.offset:+d})")
            self._emit_instr("ld", "H", f"(IX{mem.offset+1:+d})")

        self._store_from_hl(instr.dst)

    def _gen_store(self, instr: IRInstr) -> None:
        """Generate STORE instruction."""
        if not isinstance(instr.dst, MemoryLocation) or instr.src1 is None:
            return

        mem = instr.dst

        if mem.is_global:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", f"({mem.symbol_name})", "HL")
        elif mem.base is not None:
            # Store to computed address: base + offset
            # Load value into DE first
            self._load_to_de(instr.src1)
            # Load address into HL
            self._load_to_hl(mem.base)
            if mem.offset != 0:
                self._emit_instr("push", "DE")  # Save value
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")
                self._emit_instr("pop", "DE")  # Restore value
            # Store DE to (HL)
            self._emit_instr("ld", "(HL)", "E")
            self._emit_instr("inc", "HL")
            self._emit_instr("ld", "(HL)", "D")
        else:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", f"(IX{mem.offset:+d})", "L")
            self._emit_instr("ld", f"(IX{mem.offset+1:+d})", "H")

    def _gen_lea(self, instr: IRInstr) -> None:
        """Generate LEA (load effective address) instruction."""
        if not isinstance(instr.dst, VReg) or not isinstance(instr.src1, MemoryLocation):
            return

        mem = instr.src1
        if mem.is_global:
            # Load address of global variable
            self._emit_instr("ld", "HL", mem.symbol_name)
        elif mem.base is not None:
            # Computed address: base + offset
            self._load_to_hl(mem.base)
            if mem.offset != 0:
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")
        else:
            # Stack-relative address: IX + offset
            self._emit_instr("push", "IX")
            self._emit_instr("pop", "HL")
            if mem.offset != 0:
                self._emit_instr("ld", "DE", str(mem.offset))
                self._emit_instr("add", "HL", "DE")

        self._store_from_hl(instr.dst)

    def _gen_add(self, instr: IRInstr) -> None:
        """Generate ADD instruction."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("add", "HL", "DE")
        self._store_from_hl(instr.dst)

    def _gen_sub(self, instr: IRInstr) -> None:
        """Generate SUB instruction."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("or", "A")  # Clear carry
        self._emit_instr("sbc", "HL", "DE")
        self._store_from_hl(instr.dst)

    def _gen_mul(self, instr: IRInstr) -> None:
        """Generate MUL instruction (16-bit multiply via subroutine)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("call", "_mul16")
        self._store_from_hl(instr.dst)

    def _gen_div(self, instr: IRInstr) -> None:
        """Generate DIV instruction (16-bit divide via subroutine)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("call", "_div16")
        self._store_from_hl(instr.dst)

    def _gen_neg(self, instr: IRInstr) -> None:
        """Generate NEG instruction."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        # Negate HL: HL = 0 - HL
        self._emit_instr("xor", "A")
        self._emit_instr("sub", "L")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("sbc", "A", "A")
        self._emit_instr("sub", "H")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_and(self, instr: IRInstr) -> None:
        """Generate AND instruction (16-bit)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("and", "E")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("and", "D")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_or(self, instr: IRInstr) -> None:
        """Generate OR instruction (16-bit)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("or", "E")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("or", "D")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_xor(self, instr: IRInstr) -> None:
        """Generate XOR instruction (16-bit)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("xor", "E")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("xor", "D")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_not(self, instr: IRInstr) -> None:
        """Generate NOT instruction (16-bit complement)."""
        if not isinstance(instr.dst, VReg):
            return
        self._load_to_hl(instr.src1)
        self._emit_instr("ld", "A", "L")
        self._emit_instr("cpl")
        self._emit_instr("ld", "L", "A")
        self._emit_instr("ld", "A", "H")
        self._emit_instr("cpl")
        self._emit_instr("ld", "H", "A")
        self._store_from_hl(instr.dst)

    def _gen_cmp(self, instr: IRInstr) -> None:
        """Generate comparison instruction."""
        if not isinstance(instr.dst, VReg):
            return

        self._load_to_hl(instr.src1)
        self._load_to_de(instr.src2)

        # Compare HL with DE
        self._emit_instr("or", "A")  # Clear carry
        self._emit_instr("sbc", "HL", "DE")

        # Set result based on comparison type
        op = instr.opcode
        if op == OpCode.CMP_EQ:
            # Result = 1 if Z flag set
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jr", "NZ", "$+3")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_NE:
            # Result = 1 if Z flag not set
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jr", "Z", "$+3")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_LT:
            # Result = 1 if S flag set (negative result, signed)
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jp", "P", "$+4")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_GE:
            # Result = 1 if S flag not set (non-negative, signed)
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jp", "M", "$+4")
            self._emit_instr("inc", "L")
        elif op == OpCode.CMP_GT:
            # GT: not (LT or EQ) - more complex
            self._emit_instr("ld", "HL", "1")
            self._emit_instr("jp", "M", "$+6")
            self._emit_instr("jr", "Z", "$+4")
            self._emit_instr("jr", "$+3")
            self._emit_instr("dec", "L")
        elif op == OpCode.CMP_LE:
            # LE: LT or EQ
            self._emit_instr("ld", "HL", "0")
            self._emit_instr("jp", "M", "$+4")
            self._emit_instr("jr", "NZ", "$+3")
            self._emit_instr("inc", "L")

        self._store_from_hl(instr.dst)

    def _gen_jmp(self, instr: IRInstr) -> None:
        """Generate JMP instruction."""
        if isinstance(instr.dst, Label):
            self._emit_instr("jp", instr.dst.name)

    def _gen_jz(self, instr: IRInstr) -> None:
        """Generate JZ (jump if zero) instruction."""
        if isinstance(instr.dst, Label) and instr.src1:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", "A", "H")
            self._emit_instr("or", "L")
            self._emit_instr("jp", "Z", instr.dst.name)

    def _gen_jnz(self, instr: IRInstr) -> None:
        """Generate JNZ (jump if not zero) instruction."""
        if isinstance(instr.dst, Label) and instr.src1:
            self._load_to_hl(instr.src1)
            self._emit_instr("ld", "A", "H")
            self._emit_instr("or", "L")
            self._emit_instr("jp", "NZ", instr.dst.name)

    def _gen_call(self, instr: IRInstr) -> None:
        """Generate CALL instruction."""
        if isinstance(instr.dst, Label):
            self._emit_instr("call", instr.dst.name)

    def _gen_ret(self, instr: IRInstr) -> None:
        """Generate RET instruction."""
        # Put return value in HL if present
        if instr.src1:
            self._load_to_hl(instr.src1)

        # Epilogue
        if self.current_function:
            total_stack = (self.current_function.locals_size +
                          (self.reg_alloc.stack_size if self.reg_alloc else 0))
            if total_stack > 0:
                self._emit_instr("ld", "SP", "IX")
                self._emit_instr("pop", "IX")
            else:
                self._emit_instr("pop", "IX")

        self._emit_instr("ret")

    def _gen_push(self, instr: IRInstr) -> None:
        """Generate PUSH instruction."""
        if instr.src1:
            self._load_to_hl(instr.src1)
            self._emit_instr("push", "HL")

    def _gen_pop(self, instr: IRInstr) -> None:
        """Generate POP instruction."""
        if isinstance(instr.dst, VReg):
            self._emit_instr("pop", "HL")
            self._store_from_hl(instr.dst)


def generate_z80(module: IRModule) -> str:
    """Generate Z80 assembly from an IR module."""
    codegen = Z80CodeGen()
    return codegen.generate(module)
