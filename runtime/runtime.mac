; Minimal Ada Runtime Library for UADA80
; Assembled with um80 (.Z80 mode)
;
; This provides the minimal runtime routines needed for basic Ada programs.
; More complex programs may need additional runtime support.

    .Z80

    CSEG

; ============================================================
; _fin_pop_scope - Pop finalization scope
; For simple programs without controlled types, this is a no-op.
; Input: None
; Output: None
; Destroys: None
; ============================================================
    PUBLIC _fin_pop_scope
_fin_pop_scope:
    RET

; ============================================================
; _fin_push_scope - Push finalization scope
; For simple programs without controlled types, this is a no-op.
; Input: None
; Output: None
; Destroys: None
; ============================================================
    PUBLIC _fin_push_scope
_fin_push_scope:
    RET

; ============================================================
; _mul16 - 16-bit signed multiplication
; Input: HL = multiplicand, DE = multiplier
; Output: HL = product (low 16 bits)
; Destroys: A, BC, DE
; ============================================================
    PUBLIC _mul16
_mul16:
    ; Simple shift-and-add multiplication
    ; HL = HL * DE

    PUSH BC

    ; Handle sign
    LD A, H
    XOR D
    PUSH AF             ; Save result sign

    ; Make HL positive
    BIT 7, H
    JR Z, _mul16_hl_pos
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL
_mul16_hl_pos:

    ; Make DE positive
    BIT 7, D
    JR Z, _mul16_de_pos
    LD A, E
    CPL
    LD E, A
    LD A, D
    CPL
    LD D, A
    INC DE
_mul16_de_pos:

    ; Now multiply unsigned: BC = HL * DE
    LD B, H
    LD C, L             ; BC = multiplicand
    LD HL, 0            ; HL = result

_mul16_loop:
    ; Check if DE is zero
    LD A, D
    OR E
    JR Z, _mul16_done

    ; Check low bit of DE
    BIT 0, E
    JR Z, _mul16_skip
    ADD HL, BC          ; Add multiplicand to result
_mul16_skip:

    ; Shift DE right
    SRL D
    RR E

    ; Shift BC left
    SLA C
    RL B

    JR _mul16_loop

_mul16_done:
    ; Apply sign
    POP AF
    BIT 7, A
    JR Z, _mul16_ret

    ; Negate result
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL

_mul16_ret:
    POP BC
    RET

; ============================================================
; _div16 - 16-bit signed division
; Input: HL = dividend, DE = divisor
; Output: HL = quotient
; Destroys: A, BC, DE
; ============================================================
    PUBLIC _div16
_div16:
    ; Check for division by zero
    LD A, D
    OR E
    JR Z, _div16_zero

    PUSH BC

    ; Handle signs
    LD A, H
    XOR D
    PUSH AF             ; Save result sign

    ; Make HL positive
    BIT 7, H
    JR Z, _div16_hl_pos
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL
_div16_hl_pos:

    ; Make DE positive
    BIT 7, D
    JR Z, _div16_de_pos
    LD A, E
    CPL
    LD E, A
    LD A, D
    CPL
    LD D, A
    INC DE
_div16_de_pos:

    ; Unsigned division
    LD B, H
    LD C, L             ; BC = dividend
    LD HL, 0            ; HL = quotient

    ; Count bits
    LD A, 16
_div16_loop:
    ; Shift BC left into HL
    SLA C
    RL B
    ADC HL, HL

    ; Try to subtract DE from HL
    OR A                ; Clear carry
    SBC HL, DE
    JR NC, _div16_sub_ok

    ; Add back and set bit 0 of C to 0 (already 0 from shift)
    ADD HL, DE
    JR _div16_next

_div16_sub_ok:
    ; Set bit 0 of C to 1
    SET 0, C

_div16_next:
    DEC A
    JR NZ, _div16_loop

    ; Result is in BC
    LD H, B
    LD L, C

    ; Apply sign
    POP AF
    BIT 7, A
    JR Z, _div16_ret

    ; Negate result
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL

_div16_ret:
    POP BC
    RET

_div16_zero:
    ; Division by zero - return max value
    LD HL, 7FFFH
    RET

; ============================================================
; _mod16 - 16-bit signed modulo (remainder)
; Input: HL = dividend, DE = divisor
; Output: HL = remainder
; Destroys: A, BC, DE
; ============================================================
    PUBLIC _mod16
_mod16:
    ; Check for division by zero
    LD A, D
    OR E
    JR Z, _mod16_zero

    PUSH BC

    ; Save dividend sign for remainder
    LD A, H
    PUSH AF

    ; Make HL positive
    BIT 7, H
    JR Z, _mod16_hl_pos
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL
_mod16_hl_pos:

    ; Make DE positive
    BIT 7, D
    JR Z, _mod16_de_pos
    LD A, E
    CPL
    LD E, A
    LD A, D
    CPL
    LD D, A
    INC DE
_mod16_de_pos:

    ; Unsigned division - we want remainder
    LD B, H
    LD C, L             ; BC = dividend
    LD HL, 0            ; HL = remainder

    LD A, 16
_mod16_loop:
    ; Shift BC left into HL
    SLA C
    RL B
    ADC HL, HL

    ; Try to subtract DE from HL
    OR A
    SBC HL, DE
    JR NC, _mod16_sub_ok

    ; Add back
    ADD HL, DE
    JR _mod16_next

_mod16_sub_ok:
    SET 0, C

_mod16_next:
    DEC A
    JR NZ, _mod16_loop

    ; HL now contains remainder
    ; Apply dividend's sign to remainder
    POP AF
    BIT 7, A
    JR Z, _mod16_ret

    ; Negate result
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL

_mod16_ret:
    POP BC
    RET

_mod16_zero:
    LD HL, 0
    RET

; ============================================================
; _raise_constraint_error - Handle constraint error
; Called when array bounds check fails or other constraint violation.
; For CP/M, this halts the program with an error.
; Input: None
; Output: Does not return
; Destroys: All
; ============================================================
    PUBLIC _raise_constraint_error
_raise_constraint_error:
    ; Print error message using BDOS
    LD DE, _ce_msg
    LD C, 9             ; BDOS print string
    CALL 5

    ; Exit to CP/M
    JP 0                ; Warm boot

_ce_msg:
    DB 'Constraint_Error$'

; ============================================================
; _raise_program_error - Handle program error
; Input: None
; Output: Does not return
; ============================================================
    PUBLIC _raise_program_error
_raise_program_error:
    LD DE, _pe_msg
    LD C, 9
    CALL 5
    JP 0

_pe_msg:
    DB 'Program_Error$'

; ============================================================
; _raise_storage_error - Handle storage error
; Input: None
; Output: Does not return
; ============================================================
    PUBLIC _raise_storage_error
_raise_storage_error:
    LD DE, _se_msg
    LD C, 9
    CALL 5
    JP 0

_se_msg:
    DB 'Storage_Error$'

; ============================================================
; Text_IO Support
; ============================================================

; ============================================================
; _put_line - Print string and newline
; Input: String address on stack (at SP+2)
; Output: None
; Destroys: A, DE, HL
; ============================================================
    PUBLIC _put_line
_put_line:
    ; Get string address from stack
    LD HL, 2
    ADD HL, SP
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL           ; HL = string address

    ; Print the string
    CALL _put_str_hl

    ; Print newline (CR LF)
    LD E, 13            ; CR
    LD C, 2
    CALL 5
    LD E, 10            ; LF
    LD C, 2
    CALL 5
    RET

; ============================================================
; _put_string - Print string (no newline)
; Input: HL = pointer to null-terminated string
; Output: None
; Destroys: A, DE, HL
; ============================================================
    PUBLIC _put_string
_put_string:
    ; HL already contains string address
    CALL _put_str_hl
    RET

; ============================================================
; _put_str_hl - Internal: print null-terminated string
; Input: HL = pointer to null-terminated string
; Output: None
; Destroys: A, DE, HL
; ============================================================
_put_str_hl:
    LD A, (HL)
    OR A                ; Check for null terminator
    RET Z
    LD E, A
    LD C, 2             ; BDOS: console output
    PUSH HL
    CALL 5
    POP HL
    INC HL
    JR _put_str_hl

; ============================================================
; _new_line - Print newline (CR LF)
; Input: None
; Output: None
; Destroys: A, DE
; ============================================================
    PUBLIC _new_line
_new_line:
    LD E, 13            ; CR
    LD C, 2
    CALL 5
    LD E, 10            ; LF
    LD C, 2
    CALL 5
    RET

; ============================================================
; _put_int - Print signed 16-bit integer
; Input: Integer value on stack (at SP+2)
; Output: None
; Destroys: A, BC, DE, HL
; ============================================================
    PUBLIC _put_int
_put_int:
    ; Get integer from stack
    LD HL, 2
    ADD HL, SP
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL           ; HL = integer value

    ; Check for negative
    BIT 7, H
    JR Z, _put_int_pos

    ; Print minus sign
    PUSH HL
    LD E, '-'
    LD C, 2
    CALL 5
    POP HL

    ; Negate HL
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL

_put_int_pos:
    ; HL = positive value to print
    ; Use stack to store digits (pushed in reverse order)
    LD B, 0             ; digit count

_put_int_loop:
    ; Divide HL by 10, remainder is next digit
    LD DE, 10
    CALL _udiv16        ; HL = quotient, DE = remainder

    ; Push digit (remainder + '0')
    LD A, E
    ADD A, '0'
    PUSH AF
    INC B

    ; Check if quotient is zero
    LD A, H
    OR L
    JR NZ, _put_int_loop

    ; Print digits (pop and print B times)
_put_int_print:
    POP AF
    LD E, A
    LD C, 2
    PUSH BC
    CALL 5
    POP BC
    DJNZ _put_int_print

    RET

; ============================================================
; _udiv16 - Unsigned 16-bit division
; Input: HL = dividend, DE = divisor
; Output: HL = quotient, DE = remainder
; Destroys: A, BC
; ============================================================
_udiv16:
    ; Check for division by zero
    LD A, D
    OR E
    JR Z, _udiv16_zero

    PUSH BC
    LD BC, 0            ; BC = remainder
    LD A, 16            ; 16 bits

_udiv16_loop:
    ; Shift HL left, MSB into carry
    ADD HL, HL
    ; Shift carry into BC
    RL C
    RL B

    ; Try to subtract DE from BC
    PUSH HL
    LD H, B
    LD L, C
    OR A                ; clear carry
    SBC HL, DE
    JR C, _udiv16_no_sub

    ; Subtraction succeeded
    LD B, H
    LD C, L
    POP HL
    SET 0, L            ; Set quotient bit
    JR _udiv16_next

_udiv16_no_sub:
    POP HL

_udiv16_next:
    DEC A
    JR NZ, _udiv16_loop

    ; HL = quotient, BC = remainder
    LD D, B
    LD E, C
    POP BC
    RET

_udiv16_zero:
    LD HL, 0FFFFH
    LD DE, 0
    RET

; ============================================================
; _get_int - Read signed 16-bit integer from console
; Input: None
; Output: HL = integer value
; Destroys: A, BC, DE
; ============================================================
    PUBLIC _get_int
_get_int:
    LD HL, 0            ; accumulator
    LD B, 0             ; negative flag (0=positive, 1=negative)

    ; Skip leading whitespace
_get_int_skip:
    CALL _get_char_raw
    CP ' '
    JR Z, _get_int_skip
    CP 9                ; TAB
    JR Z, _get_int_skip
    CP 13               ; CR
    JR Z, _get_int_skip
    CP 10               ; LF
    JR Z, _get_int_skip

    ; Check for minus sign
    CP '-'
    JR NZ, _get_int_not_neg
    LD B, 1             ; set negative flag
    CALL _get_char_raw  ; get next char
    JR _get_int_digit

_get_int_not_neg:
    ; Check for plus sign
    CP '+'
    JR NZ, _get_int_digit
    CALL _get_char_raw  ; skip plus, get next char

_get_int_digit:
    ; A contains current char, check if digit
    CP '0'
    JR C, _get_int_done
    CP '9'+1
    JR NC, _get_int_done

    ; It's a digit, multiply accumulator by 10 and add digit
    SUB '0'             ; A = digit value
    PUSH AF             ; save digit
    PUSH BC             ; save negative flag

    ; HL = HL * 10
    LD D, H
    LD E, L
    ADD HL, HL          ; HL * 2
    ADD HL, HL          ; HL * 4
    ADD HL, DE          ; HL * 5
    ADD HL, HL          ; HL * 10

    POP BC              ; restore negative flag
    POP AF              ; restore digit
    LD E, A
    LD D, 0
    ADD HL, DE          ; HL = HL * 10 + digit

    ; Get next character
    CALL _get_char_raw
    JR _get_int_digit

_get_int_done:
    ; Apply negative flag
    LD A, B
    OR A
    RET Z               ; positive, return HL as-is

    ; Negate HL
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    INC HL
    RET

; ============================================================
; _get_char - Read single character from console
; Input: None
; Output: HL = character (low byte, high byte = 0)
; Destroys: A
; ============================================================
    PUBLIC _get_char
_get_char:
    CALL _get_char_raw
    LD L, A
    LD H, 0
    RET

; ============================================================
; _get_char_raw - Read raw character using BDOS
; Input: None
; Output: A = character
; Destroys: None (except A)
; ============================================================
_get_char_raw:
    PUSH BC
    PUSH DE
    PUSH HL
    LD C, 1             ; BDOS: Console input
    CALL 5
    POP HL
    POP DE
    POP BC
    RET

    END
